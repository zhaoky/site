import{_ as A,C as u,c as h,o as n,R as i,b as a,k as o,w as r,a as l,G as e,a1 as g}from"./chunks/framework.Dxoqk0BT.js";const E="/img/mind-map.png",p=JSON.parse('{"title":"前端知识体系","description":"","frontmatter":{},"headers":[],"relativePath":"exp/misc/416.md","filePath":"exp/misc/416.md"}'),d={name:"exp/misc/416.md"};function c(B,t,b,m,S,f){const s=u("Mermaid");return n(),h("div",null,[t[8]||(t[8]=i('<h1 id="前端知识体系" tabindex="-1">前端知识体系 <a class="header-anchor" href="#前端知识体系" aria-label="Permalink to &quot;前端知识体系&quot;">​</a></h1><p><img src="'+E+'" alt="前端大纲图谱"></p><h2 id="体系化思维的重要性" tabindex="-1">体系化思维的重要性 <a class="header-anchor" href="#体系化思维的重要性" aria-label="Permalink to &quot;体系化思维的重要性&quot;">​</a></h2><p>当我们去思考一个比较系统的、大篇幅的事情时，一定要有<strong>体系化思维</strong>，要做成一棵树，而不是一盆散沙。所以，相比于本文的内容来说，体系化的思维更加重要，会让你终身受益。</p><p>例如一个学校有 2w 学生，如何组织这么多学生？就要分学院、分专业、分班级，班级下面还要再分宿舍。这样才能把这些学生管理起来，哪怕再扩展 5k 学生，也能通过这套管理体系来管理。</p><p>这同样适用于我们的前端知识，前端领域知识非常杂乱，需要学习的东西很多，你如何管理它呢？如果让你写一本《前端大全》的书，你如何制定目录呢？—— 你别掰着手指头，想到一个写一个，那就乱了。</p><p>红宝书？红宝书是 JS 相关的，而前端可不仅仅是 JS 。而且，从 JS 视角来看红宝书目录是合理的，一旦上升一个视角，从整个前端视角来看，红宝书目录就不一定合理了。</p><p>例如从 JS 视角来看网络请求，可能更接近的是 <strong>Ajax</strong> ，而从前端视角来看网络请求，可能更多是 <strong>HTTP 协议</strong> 。角度不一样，内容和侧重点就不一样。</p><p>新入门的前端同学需要有体系化思维，只有一个系统的体系才能帮助你全面、无死角的掌握所有技能。哪怕你没法近期掌握所有技能，你也知道哪些你会，哪些你不会（<strong>重要！！！</strong>），因为有一个体系目录给你参考。</p><p>前端老司机们更需要掌握体系化思维，系统和体系才能让你的学习和工作更有条理性，才能让你把多年累积的杂乱的技能和工作经验，总结转换为自己的体系知识。否则，没有体系，积累的越多，你就越乱。</p><p>N 年之前我就写过一个前端知识体系 <strong>What is FE</strong>，这次重写，以更广泛的技术视野，展现更全面、更详细的内容。</p><h2 id="计算机基础" tabindex="-1">计算机基础 <a class="header-anchor" href="#计算机基础" aria-label="Permalink to &quot;计算机基础&quot;">​</a></h2><p>本科或考研计算机专业的专业课。其中数据结构和算法下文单独写。</p><h3 id="计算机组成原理" tabindex="-1">计算机组成原理 <a class="header-anchor" href="#计算机组成原理" aria-label="Permalink to &quot;计算机组成原理&quot;">​</a></h3><p>主要内容：</p><ul><li><strong>冯诺依曼结构 Von Neumann Architecture</strong> - 一种计算机体系结构，它将存储程序、数据和指令都存放在同一内存中，通过中央处理器依次读取指令并执行，从而实现计算机的基本操作。</li><li><strong>二进制 Binary</strong> - 一种数值表示方式，使用 0 和 1 两个数字，通过不同的组合表示各种数值和信息，是计算机内部数据存储和处理的基本方式。</li><li><strong>中央处理器 CPU</strong> - 计算机的核心部件，负责执行指令和控制数据流。包含算术逻辑单元（ALU）、控制单元（CU）、寄存器等部分。</li><li><strong>指令集架构 ISA</strong> - 指令集架构定义了计算机能够理解和执行的指令集合，包括指令格式、操作码、寻址模式等。</li><li><strong>内存 Memory</strong> - 存储程序和数据，主要包括主存储器（RAM）和外部存储（硬盘、SSD）等，存储层次结构影响计算机的性能</li><li><strong>缓存 Cache</strong> - 高速存储器，用于存储常用数据，以减少 CPU 对主存的访问延迟，提高处理效率</li><li><strong>总线 Bus</strong> - 计算机内部用于数据传输的通道，分为数据总线、地址总线和控制总线，用于连接 CPU、内存和外部设备。</li><li><strong>输入输出 I/O</strong> - 系统负责计算机与外部设备之间的数据交换，通常涉及 I/O 控制器、驱动程序和数据传输机制。</li></ul><p>计算机组成原理帮助我们掌握计算机硬件的基本工作原理，为后续的操作系统、计算机网络等高级课程奠定基础。</p>',17)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-90",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20A%5B%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87%5D%20--%3E%20B%5B%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%20CPU%5D%0A%20%20%20%20B%20--%3E%20C%5B%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%5D%0A%20%20%20%20B%20%3C--%3E%20D%5B%E5%86%85%E5%AD%98%20Memory%5D%0A%20%20%20%20D%20--%3E%20E%5B%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%5D%0A%20%20%20%20B%20--%3E%20F%5B%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%20ALU%5D%0A%20%20%20%20B%20--%3E%20G%5B%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%20CU%5D%0A%20%20%20%20B%20--%3E%20H%5B%E5%AF%84%E5%AD%98%E5%99%A8%5D%0A%20%20%20%20I%5B%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%5D%20%3C--%3E%20D%0A%0A%20%20%20%20style%20B%20fill%3A%23e1f5fe%0A%20%20%20%20style%20D%20fill%3A%23f3e5f5%0A%20%20%20%20style%20F%20fill%3A%23fff3e0%0A%20%20%20%20style%20G%20fill%3A%23fff3e0%0A%20%20%20%20style%20H%20fill%3A%23fff3e0%0A"})]),fallback:r(()=>[...t[0]||(t[0]=[l(" Loading... ",-1)])]),_:1})),t[9]||(t[9]=i('<h4 id="冯诺依曼计算机体系结构" tabindex="-1">冯诺依曼计算机体系结构 <a class="header-anchor" href="#冯诺依曼计算机体系结构" aria-label="Permalink to &quot;冯诺依曼计算机体系结构&quot;">​</a></h4><h3 id="操作系统" tabindex="-1">操作系统 <a class="header-anchor" href="#操作系统" aria-label="Permalink to &quot;操作系统&quot;">​</a></h3><p>操作系统管理计算机的所有资源，进程控制，内存分配等。重要内容如下：</p><ul><li><strong>进程 Process</strong> - 正在执行的程序的实例，包含程序代码、数据、堆栈等执行状态。</li><li><strong>线程 Thread</strong> - 线程是进程中的基本执行单元，同一个进程的多个线程共享进程的资源，但每个线程有自己的执行栈。</li><li><strong>调度 Scheduling</strong> - 是操作系统管理多个进程或线程执行顺序的过程，常见的调度算法有先来先服务、时间片轮转、优先级调度等。</li><li><strong>内存管理 Memory Management</strong> - 负责分配和回收内存资源，常用技术包括分页、分段和虚拟内存。</li><li><strong>虚拟内存 Virtual Memory</strong> - 一种扩展内存容量的技术，通过将部分内存数据交换到磁盘，使程序能使用比物理内存更大的地址空间。</li><li><strong>文件系统 File System</strong> - 用于管理存储设备上的文件，包括文件的创建、读取、删除及存储结构，如 FAT、NTFS、EXT 等</li><li><strong>输入输出管理 I/O</strong> - 负责计算机与外部设备之间的数据传输，涉及设备驱动、缓存管理、中断处理等技术。</li></ul><p>操作系统的核心概念（内存、进程、线程、文件等）对于前端开发都非常重要，例如 <strong>JS 是单线程的</strong>。深入理解基础概念才能让你成为优秀程序员，否则只能浮于表面开发 <strong>CRUD</strong> 。</p><h3 id="编译原理" tabindex="-1">编译原理 <a class="header-anchor" href="#编译原理" aria-label="Permalink to &quot;编译原理&quot;">​</a></h3><p>编译原理，主要讲解一个编译器如何设计和开发。</p><ul><li><strong>词法分析 lexical Analysis</strong> - 将源代码分解为基本的语法单元（词法单元，Token），如关键字、标识符、运算符等。</li><li><strong>语法分析 Syntax Analysis</strong> - 将词法分析的输出（Token 流）根据语言的语法规则构建成语法树或抽象语法树（AST）。</li><li><strong>抽象语法树 AST</strong> - 是对程序结构的抽象表示，去除了具体的语法细节，保留了程序的逻辑结构。</li><li><strong>语义分析 Semantic Analysis</strong> - 检查程序的语义是否符合语言的规则，如类型检查、变量是否声明等。</li><li><strong>中间代码 Intermediate Code</strong> - 是编译过程中的一种中间表示，它介于源代码和目标代码之间，便于优化和代码生成。</li><li><strong>优化 Optimization</strong> - 是对中间代码或目标代码进行改进，以提高程序的运行效率或减少资源消耗，常见的有死代码消除、循环优化等。</li><li><strong>代码生成 Code Generation</strong> - 将中间代码转换为目标代码（机器代码或汇编代码），是编译过程的最后阶段。</li></ul><p>前端常见的编译器有 <strong>babel</strong>、<strong>SWC</strong>、<strong>vue-compiler</strong> 等，无论用什么语言，用 JS 还是 Rust，都是按照编译原理的过程开发的。</p>',9)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-186",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20A%5B%E6%BA%90%E4%BB%A3%E7%A0%81%5D%20--%3E%20B%5B%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%5D%0A%20%20%20%20B%20--%3E%20C%5BToken%20%E6%B5%81%5D%0A%20%20%20%20C%20--%3E%20D%5B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%5D%0A%20%20%20%20D%20--%3E%20E%5B%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%20AST%5D%0A%20%20%20%20E%20--%3E%20F%5B%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%5D%0A%20%20%20%20F%20--%3E%20G%5B%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%5D%0A%20%20%20%20G%20--%3E%20H%5B%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%5D%0A%20%20%20%20H%20--%3E%20I%5B%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%5D%0A%0A%20%20%20%20style%20A%20fill%3A%23e8f5e8%0A%20%20%20%20style%20E%20fill%3A%23fff3e0%0A%20%20%20%20style%20I%20fill%3A%23e1f5fe%0A"})]),fallback:r(()=>[...t[1]||(t[1]=[l(" Loading... ",-1)])]),_:1})),t[10]||(t[10]=i('<h4 id="编译器工作流程" tabindex="-1">编译器工作流程 <a class="header-anchor" href="#编译器工作流程" aria-label="Permalink to &quot;编译器工作流程&quot;">​</a></h4><h3 id="汇编语言" tabindex="-1">汇编语言 <a class="header-anchor" href="#汇编语言" aria-label="Permalink to &quot;汇编语言&quot;">​</a></h3><p>汇编语言是接近机器语言的低级编程语言，使用助记符表示机器指令，直接控制计算机硬件。</p><ul><li><strong>指令集 Intruction Set</strong> - 每种处理器都拥有一组特定的指令集，定义了处理器能执行的基本操作，如数据传输、算术运算等。</li><li><strong>助记符 Mnemonic</strong> - 助记符是用来代表机器指令的符号，如 MOV（数据传输）、ADD（加法）等，简化了编程工作。</li><li><strong>寄存器 Register</strong> - 寄存器是 CPU 内部的高速存储器，用于存储程序执行过程中临时数据或计算结果。</li><li><strong>机器码 Machine Code</strong> - 机器码是计算机能够直接执行的二进制指令，每条汇编指令都对应一条机器码。</li><li><strong>内存寻址 Memory Addressing</strong> - 内存寻址是指访问计算机内存中数据的位置，汇编语言中常用的寻址模式有直接寻址、间接寻址、基址寻址等。</li><li><strong>堆栈模型 Stack and Heap</strong> - 一种数据结构模型，采用后进先出（LIFO）原则，数据项按顺序压入堆栈并从堆栈中弹出，用于存储临时数据、函数调用信息等。</li></ul><p>前端开发不会用到，但学习它的指令集和堆栈模型，有助于我们深入理解编程语言的执行过程。</p><h3 id="计算机网络" tabindex="-1">计算机网络 <a class="header-anchor" href="#计算机网络" aria-label="Permalink to &quot;计算机网络&quot;">​</a></h3><p>计算机网络讲解计算机之间的通讯原理和技术，有很多前端开发常见的概念。主要内容：</p><ul><li><strong>OSI 模型 OSI Model</strong> - 开放系统互联模型，将计算机网络通信分为七层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</li><li><strong>TCP/IP 协议 TCP/IP Protocol</strong> - TCP/IP 协议是互联网的基础协议，主要包括传输控制协议（TCP）和网际协议（IP），定义了数据传输和路由机制。</li><li><strong>IP 地址 IP Address</strong> - IP 地址是计算机网络中用于标识设备的唯一地址，分为 IPv4 和 IPv6 两种格式。</li><li><strong>路由 Routing</strong> - 路由是数据包在网络中从源设备传输到目的设备的过程，涉及路由协议和路由算法。</li><li><strong>域名 Domain</strong> - 互联网中用于标识和定位网站的文字地址，通常由字母、数字和符号组成，并与 IP 地址一一对应，便于用户访问网站。</li><li><strong>DNS Domain Name System</strong> - 域名系统将域名，如 &lt;www.example.com&gt; 转换为 IP 地址，使用户可以通过易记的域名访问网站。</li><li><strong>UDP User Datagram Protocol</strong> - 用户数据报协议是一种无连接的传输层协议，适用于对速度要求高而对可靠性要求低的应用。</li><li><strong>TCP Transmission Control Protocol</strong> - 传输控制协议是一种面向连接的协议，提供可靠的数据传输，保证数据包按顺序到达并且无误。TCP 连接的&quot;<strong>三次握手 四次挥手</strong>&quot;是面试常考内容。</li><li><strong>端口号 Port Number</strong> - 端口号是用于区分同一 IP 地址上不同服务或应用程序的标识符，通常由操作系统分配。</li><li><strong>HTTP Hypertext Transfer Protocol</strong> - 超文本传输协议是用于客户端与服务器之间传输网页数据的协议，基于请求-响应模式。下文会再展开讲解。</li><li><strong>FTP File Transfer Protocol</strong> - 文件传输协议用于在网络上进行文件传输，支持上传和下载文件。</li><li><strong>CDN（内容分发网络）</strong> - 是通过在全球多个地点部署缓存服务器，将网站或应用的静态资源（如图片、视频、JS 文件等）分发到离用户更近的服务器，以提高访问速度和减少延迟。</li><li><strong>边缘计算 Edge Compute</strong> - 在离数据源或用户更近的网络边缘设备上进行数据处理和分析，减少数据传输延迟，提高实时响应能力。现在很多云服务商 <strong>Vercel</strong> 和 <strong>Deno</strong> 都在推行 Edge 计算。</li></ul>',8)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-304",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20subgraph%20%22OSI%20%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%22%0A%20%20%20%20%20%20%20%20A7%5B%E5%BA%94%E7%94%A8%E5%B1%82%20Application%5D%0A%20%20%20%20%20%20%20%20A6%5B%E8%A1%A8%E7%A4%BA%E5%B1%82%20Presentation%5D%0A%20%20%20%20%20%20%20%20A5%5B%E4%BC%9A%E8%AF%9D%E5%B1%82%20Session%5D%0A%20%20%20%20%20%20%20%20A4%5B%E4%BC%A0%E8%BE%93%E5%B1%82%20Transport%5D%0A%20%20%20%20%20%20%20%20A3%5B%E7%BD%91%E7%BB%9C%E5%B1%82%20Network%5D%0A%20%20%20%20%20%20%20%20A2%5B%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%20Data%20Link%5D%0A%20%20%20%20%20%20%20%20A1%5B%E7%89%A9%E7%90%86%E5%B1%82%20Physical%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22TCP%2FIP%20%E5%8D%8F%E8%AE%AE%E6%A0%88%22%0A%20%20%20%20%20%20%20%20B4%5B%E5%BA%94%E7%94%A8%E5%B1%82%3Cbr%2F%3EHTTP%2C%20FTP%2C%20DNS%5D%0A%20%20%20%20%20%20%20%20B3%5B%E4%BC%A0%E8%BE%93%E5%B1%82%3Cbr%2F%3ETCP%2C%20UDP%5D%0A%20%20%20%20%20%20%20%20B2%5B%E7%BD%91%E7%BB%9C%E5%B1%82%3Cbr%2F%3EIP%2C%20ICMP%5D%0A%20%20%20%20%20%20%20%20B1%5B%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82%3Cbr%2F%3EEthernet%2C%20WiFi%5D%0A%20%20%20%20end%0A%0A%20%20%20%20A7%20--%3E%20B4%0A%20%20%20%20A6%20--%3E%20B4%0A%20%20%20%20A5%20--%3E%20B4%0A%20%20%20%20A4%20--%3E%20B3%0A%20%20%20%20A3%20--%3E%20B2%0A%20%20%20%20A2%20--%3E%20B1%0A%20%20%20%20A1%20--%3E%20B1%0A%0A%20%20%20%20style%20A7%20fill%3A%23e8f5e8%0A%20%20%20%20style%20A4%20fill%3A%23fff3e0%0A%20%20%20%20style%20A3%20fill%3A%23e1f5fe%0A%20%20%20%20style%20A1%20fill%3A%23f3e5f5%0A%20%20%20%20style%20B4%20fill%3A%23e8f5e8%0A%20%20%20%20style%20B3%20fill%3A%23fff3e0%0A%20%20%20%20style%20B2%20fill%3A%23e1f5fe%0A%20%20%20%20style%20B1%20fill%3A%23f3e5f5%0A"})]),fallback:r(()=>[...t[2]||(t[2]=[l(" Loading... ",-1)])]),_:1})),t[11]||(t[11]=i('<h4 id="osi-七层模型与-tcp-ip-协议栈对比" tabindex="-1">OSI 七层模型与 TCP/IP 协议栈对比 <a class="header-anchor" href="#osi-七层模型与-tcp-ip-协议栈对比" aria-label="Permalink to &quot;OSI 七层模型与 TCP/IP 协议栈对比&quot;">​</a></h4><h3 id="编码" tabindex="-1">编码 <a class="header-anchor" href="#编码" aria-label="Permalink to &quot;编码&quot;">​</a></h3><p>编码主要讲解信息的表示、转换和传输，即我们所见的任何信息在计算机内部是如何表示的。例如：</p><ul><li><strong>ASCII 编码</strong> - 是一种字符编码标准，用于表示英文字符、数字、标点符号以及一些控制字符。它使用 7 位二进制数（即 0 到 127 之间的整数）来表示各种字符，其中每个字符对应一个唯一的数字编码。例如： <ul><li>字符 A 对应的 ASCII 编码是 65（二进制表示为 01000001）</li><li>字符 a 是 97（二进制 01100001）</li></ul></li><li><strong>Unicode 编码</strong> - 是一个字符编码标准，用于统一表示世界上几乎所有的文字和符号。它为每个字符分配一个唯一的数字标识（称为码点），并支持多种语言、符号以及其他字符集，包括汉字、拉丁字母、数学符号、表情符号等。Unicode 包含了超过 137,000 个字符，覆盖了几乎所有的书写系统。Unicode 的设计目的是让全球的字符集标准统一，从而解决多种字符编码的兼容性问题。</li><li><strong>UTF-8</strong> - Unicode 的一种编码方式，使用 1 到 4 个字节来表示一个字符，是目前最流行的 Unicode 实现，兼容 ASCII。</li><li><strong>UTF-16</strong> - Unicode 的一种编码方式，使用 2 或 4 个字节来表示一个字符，适用于东亚语言。</li><li><strong>GBK 编码</strong> - 是中国国家标准对简体和繁体中文字符集的一种扩展编码，继承了 GB2312 编码，并加入了更多的字符，广泛用于中文环境中的计算机系统、文本文件以及网络传输。随着 Unicode 的普及，GBK 逐渐被 Unicode 编码（如 UTF-8、UTF-16）所替代，但在一些旧系统和遗留应用中，GBK 编码仍然被使用。</li></ul><p>HTML 和 HTTP 请求时都有一个 <strong>charset</strong> 就表示使用哪种编码类型。如我开发的 <strong>划水 AI</strong> 项目默认的编码是 <strong>utf-8</strong></p><h2 id="数据结构和算法" tabindex="-1">数据结构和算法 <a class="header-anchor" href="#数据结构和算法" aria-label="Permalink to &quot;数据结构和算法&quot;">​</a></h2><h3 id="常见数据结构" tabindex="-1">常见数据结构 <a class="header-anchor" href="#常见数据结构" aria-label="Permalink to &quot;常见数据结构&quot;">​</a></h3><ul><li><strong>数组 Array</strong> - 数组是一种数据结构，用于存储具有相同数据类型的元素，元素在内存中是连续存储的。</li><li><strong>链表 Linked List</strong> - 链表是一种线性数据结构，其中每个元素（节点）包含数据和指向下一个节点的指针。</li><li><strong>栈 Stack</strong> - 栈是一种后进先出（LIFO）的数据结构，元素只能在一端进行插入和删除操作。</li><li><strong>队列 Queue</strong> - 队列是一种先进先出（FIFO）的数据结构，元素从队列的一端插入，从另一端删除。</li><li><strong>哈希表 Hash Table</strong> - 哈希表是一种通过哈希函数将键映射到对应值的查找结构，具有快速的插入、删除和查找操作。</li><li><strong>树 Tree</strong> - 树是一种分层的数据结构，由节点组成，其中每个节点有一个父节点和多个子节点。</li><li><strong>二叉树 Binary Tree</strong> - 二叉树是一种树形结构，每个节点最多有两个子节点，分别是左子节点和右子节点。</li><li><strong>平衡二叉树 AVL Tree</strong> - 平衡二叉树是一种自平衡的二叉搜索树，保证左右子树的高度差不超过 1，从而保持操作的时间复杂度为 O(logn)。</li><li><strong>堆 Heap</strong> - 堆是一种特殊的完全二叉树，满足堆的性质（如最大堆或最小堆），广泛用于优先队列实现。</li><li><strong>图 Grahp</strong> - 图是由节点和边组成的数据结构，可以表示一对多的关系，分为有向图和无向图。</li></ul>',8)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-414",class:"mermaid",graph:"graph%20TB%0A%20%20%20%20subgraph%20%22%E6%95%B0%E7%BB%84%20Array%22%0A%20%20%20%20%20%20%20%20A1%5B0%3A%20a%5D%20---%20A2%5B1%3A%20b%5D%20---%20A3%5B2%3A%20c%5D%20---%20A4%5B3%3A%20d%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22%E9%93%BE%E8%A1%A8%20Linked%20List%22%0A%20%20%20%20%20%20%20%20L1%5BNode1%3Cbr%2F%3Edata%3A%20a%3Cbr%2F%3Enext%3A%20%E2%86%92%5D%20--%3E%20L2%5BNode2%3Cbr%2F%3Edata%3A%20b%3Cbr%2F%3Enext%3A%20%E2%86%92%5D%0A%20%20%20%20%20%20%20%20L2%20--%3E%20L3%5BNode3%3Cbr%2F%3Edata%3A%20c%3Cbr%2F%3Enext%3A%20null%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22%E6%A0%88%20Stack%20(LIFO)%22%0A%20%20%20%20%20%20%20%20S3%5Bc%5D%0A%20%20%20%20%20%20%20%20S2%5Bb%5D%0A%20%20%20%20%20%20%20%20S1%5Ba%5D%0A%20%20%20%20%20%20%20%20S3%20-.-%3E%20S2%20-.-%3E%20S1%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22%E9%98%9F%E5%88%97%20Queue%20(FIFO)%22%0A%20%20%20%20%20%20%20%20Q1%5Ba%5D%20--%3E%20Q2%5Bb%5D%20--%3E%20Q3%5Bc%5D%0A%20%20%20%20%20%20%20%20Q4%5B%E5%87%BA%E9%98%9F%5D%20-.-%3E%20Q1%0A%20%20%20%20%20%20%20%20Q3%20-.-%3E%20Q5%5B%E5%85%A5%E9%98%9F%5D%0A%20%20%20%20end%0A%0A%20%20%20%20subgraph%20%22%E4%BA%8C%E5%8F%89%E6%A0%91%20Binary%20Tree%22%0A%20%20%20%20%20%20%20%20T1%5BA%5D%0A%20%20%20%20%20%20%20%20T2%5BB%5D%0A%20%20%20%20%20%20%20%20T3%5BC%5D%0A%20%20%20%20%20%20%20%20T4%5BD%5D%0A%20%20%20%20%20%20%20%20T5%5BE%5D%0A%20%20%20%20%20%20%20%20T1%20--%3E%20T2%0A%20%20%20%20%20%20%20%20T1%20--%3E%20T3%0A%20%20%20%20%20%20%20%20T2%20--%3E%20T4%0A%20%20%20%20%20%20%20%20T2%20--%3E%20T5%0A%20%20%20%20end%0A%0A%20%20%20%20style%20A1%20fill%3A%23e8f5e8%0A%20%20%20%20style%20L1%20fill%3A%23fff3e0%0A%20%20%20%20style%20S3%20fill%3A%23e1f5fe%0A%20%20%20%20style%20Q1%20fill%3A%23f3e5f5%0A%20%20%20%20style%20T1%20fill%3A%23fce4ec%0A"})]),fallback:r(()=>[...t[3]||(t[3]=[l(" Loading... ",-1)])]),_:1})),t[12]||(t[12]=i('<h4 id="常见数据结构示意图" tabindex="-1">常见数据结构示意图 <a class="header-anchor" href="#常见数据结构示意图" aria-label="Permalink to &quot;常见数据结构示意图&quot;">​</a></h4><h3 id="常见算法" tabindex="-1">常见算法 <a class="header-anchor" href="#常见算法" aria-label="Permalink to &quot;常见算法&quot;">​</a></h3><ul><li><strong>查找算法 Searching Algorithms</strong> - 查找算法用于在数据结构中查找特定元素，常见的查找算法包括线性查找、二分查找等。</li><li><strong>排序算法 Sorting Algorithms</strong> - 排序算法用于将数据元素按某种顺序排列，常见的排序算法包括冒泡排序、快速排序、归并排序等。</li><li><strong>深度优先搜索 DFS</strong> - 深度优先搜索是一种遍历图或树的算法，优先访问每个节点的子节点，直到访问到最深层才回溯。</li><li><strong>广度优先搜索 BFS</strong> - 广度优先搜索是一种遍历图或树的算法，优先访问每一层的节点，再逐层向下扩展。</li><li><strong>分治法 Divide and Conquer</strong> - 是一种将问题分解为多个子问题并递归解决的算法设计方法，常见于归并排序、快速排序等算法。</li><li><strong>贪心算法 Greedy Algorithm</strong> - 是一种通过局部最优解推导全局最优解的算法策略，常见于最短路径、背包问题等。</li><li><strong>回溯法 Backtracking</strong> - 是一种系统地寻找所有可能解的算法，通过递归逐步构造解并回退，以找到正确的解。</li><li><strong>动态规划 Dynamic Programming</strong> - 是一种优化算法，用于解决具有重叠子问题的最优子结构问题，常见于求解最短路径、背包问题等。</li><li><strong>最短路径算法 Shortest Path Algorithm</strong> - 最短路径算法用于在图中找到从一个节点到另一个节点的最短路径，常见的算法有 Dijkstra 算法、Bellman-Ford 算法等。</li><li><strong>KMP 算法</strong> - 是一种用于字符串匹配的高效算法，通过预处理模式串来提高匹配效率，避免重复匹配。将时间复杂度由 O(m*n) 缩短为 O(m+n)。</li><li><strong>双指针 Two Pointer</strong> - 是一种通过使用两个指针在数据结构（如数组或链表）上进行遍历来解决问题的算法技巧，通常用于查找、排序或优化操作，能够有效减少时间复杂度。</li></ul><h3 id="算法复杂度" tabindex="-1">算法复杂度 <a class="header-anchor" href="#算法复杂度" aria-label="Permalink to &quot;算法复杂度&quot;">​</a></h3><ul><li><strong>时间复杂度 Time Complexity</strong> - 是衡量算法执行时间随输入规模变化的增长速度的指标，通常用大 O 符号表示，用来评估算法在最坏情况下的性能表现。</li><li><strong>空间复杂度 Space Complexity</strong> - 是衡量算法在执行过程中所需内存空间随输入规模变化的增长速度，通常用大 O 符号表示，反映了算法对内存资源的需求。</li><li><strong>O(1)</strong> - 无循环</li><li><strong>O(n)</strong> - 一层循环</li><li><strong>O(logn)</strong> - 分治</li><li><strong>O(n*logn)</strong> - 一层循环 + 分治</li><li><strong>O(n^2)</strong> - 两层嵌套循环</li></ul>',5)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-518",class:"mermaid",graph:"xychart-beta%0A%20%20%20%20title%20%22%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83%22%0A%20%20%20%20x-axis%20%5B%E8%BE%93%E5%85%A5%E8%A7%84%E6%A8%A1%20n%5D%0A%20%20%20%20y-axis%20%5B%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%5D%0A%20%20%20%20line%20%5B1%2C%201%2C%201%2C%201%2C%201%5D%20%22O(1)%20%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%22%0A%20%20%20%20line%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%20%22O(n)%20%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%22%0A%20%20%20%20line%20%5B1%2C%202%2C%204%2C%208%2C%2016%5D%20%22O(log%20n)%20%E5%AF%B9%E6%95%B0%E6%97%B6%E9%97%B4%22%0A%20%20%20%20line%20%5B1%2C%204%2C%209%2C%2016%2C%2025%5D%20%22O(n%C2%B2)%20%E5%B9%B3%E6%96%B9%E6%97%B6%E9%97%B4%22%0A%20%20%20%20line%20%5B1%2C%204%2C%2012%2C%2032%2C%2080%5D%20%22O(n%20log%20n)%22%0A"})]),fallback:r(()=>[...t[4]||(t[4]=[l(" Loading... ",-1)])]),_:1})),t[13]||(t[13]=i('<h4 id="常见算法时间复杂度增长趋势" tabindex="-1">常见算法时间复杂度增长趋势 <a class="header-anchor" href="#常见算法时间复杂度增长趋势" aria-label="Permalink to &quot;常见算法时间复杂度增长趋势&quot;">​</a></h4><h2 id="编程模式" tabindex="-1">编程模式 <a class="header-anchor" href="#编程模式" aria-label="Permalink to &quot;编程模式&quot;">​</a></h2><h3 id="oop-面向对象编程" tabindex="-1">OOP 面向对象编程 <a class="header-anchor" href="#oop-面向对象编程" aria-label="Permalink to &quot;OOP 面向对象编程&quot;">​</a></h3><p>面向对象编程是现代编程开发最重要的编程模式，常见的现代编程语言都支持。</p><ul><li><strong>类 Class</strong> - 用于定义对象的蓝图或模板，包含对象的属性和方法。</li><li><strong>对象 Object</strong> - 类的实例，通过类创建，具有类定义的属性和方法。</li><li><strong>继承 Inheritance</strong> - 通过继承，一个类可以继承另一个类的属性和方法，从而实现代码重用和扩展。</li><li><strong>封装 Encapsulation</strong> - 将数据和操作数据的方法封装在一个类中，对外提供接口而隐藏实现细节，提高代码的安全性和可维护性。</li><li><strong>多态 Polymorphism</strong> - 允许不同类的对象以相同的接口调用，从而实现不同的行为表现。</li><li><strong>抽象 Abstraction</strong> - 是将复杂的现实世界问题简化为重要的特征，隐藏不必要的细节，提供简洁的接口。</li><li><strong>方法 Mothod</strong> - 类中的函数，定义了对象能够执行的操作或行为。</li><li><strong>属性 Attribute</strong> - 类的成员变量，用于存储对象的状态信息。</li><li><strong>构造函数 Constructor</strong> - 用于在创建对象时初始化对象的特殊方法。</li><li><strong>接口 Interface</strong> - 定义了类必须实现的方法的集合，用于提供不同类之间的协议或约定。</li></ul><h3 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h3><p><strong>SOLID 5 大设计原则</strong>（至少要能深刻理解前两个原则）：</p><ul><li><strong>单一职责原则</strong> - 每个类应该只有一个职责，意味着一个类应该只有一个原因去改变。类应专注于一个功能，避免承担过多责任。</li><li><strong>开放封闭原则</strong> - 软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。即，允许在不修改现有代码的情况下，通过增加新代码来扩展功能。</li><li><strong>里氏替换原则</strong> - 子类对象应该能够替换父类对象，并且程序的行为应该保持一致。换句话说，继承关系应该保证子类能够正确地替代父类。</li><li><strong>接口隔离原则</strong> - 不应该强迫客户依赖于他们不需要的接口。一个类不应该实现它不使用的接口方法，而是将接口划分为更小、更专注的接口。</li><li><strong>依赖倒置原则</strong> - 高层模块不应该依赖低层模块，二者应该依赖抽象；抽象不应该依赖于细节，细节应该依赖于抽象。这样可以减少模块之间的耦合度，提高系统的灵活性和可维护性。</li></ul><p>传统设计模式有 23 个，前端最常见的有如下几个：</p><ul><li><strong>工厂模式</strong> - 封装实例的创建过程，解放 new Class()，Vue React 内部都在用。</li><li><strong>单例模式</strong> - 全局只允许有一个实例，多则出错。用 TS 语法实现更优雅。</li><li><strong>观察者模式</strong> - 前端（及其他 UI 编程）最常用的设计模式，工作必用，面试必考。</li><li><strong>迭代器模式</strong> - 遍历数据不仅仅是 for 和 forEach ，还有更高级的 Iterator ，JS 早已支持了。</li><li><strong>装饰器模式</strong> - Decorator 现已是 JS 的标准语法，装饰器正在前端普及开来。</li><li><strong>原型模式</strong> - 原型和原型链是 JS 必备的基础知识，还扩展了 JS 对象属性描述符。</li><li><strong>代理模式</strong> - 编程处处有代理，无论开发环境还是线上环境。Vue3 也用 Proxy 实现数据响应式。</li></ul><h3 id="fp-函数式编程" tabindex="-1">FP 函数式编程 <a class="header-anchor" href="#fp-函数式编程" aria-label="Permalink to &quot;FP 函数式编程&quot;">​</a></h3><p>随着 React 的发展，函数式编程在前端开发被广泛使用，主要内容是：</p><ul><li><strong>纯函数 Pure Function</strong> - 指的是不依赖于外部状态且不修改外部状态的函数，对于相同的输入总是返回相同的输出。</li><li><strong>不可变性 Immutability</strong> - 数据一旦创建后不可修改，任何变更都会生成新的数据。</li><li><strong>副作用 Side Effect</strong> - 函数外部的状态改变，如修改全局变量、I/O 操作等，函数式编程尽量避免副作用，以保持函数的纯粹性。</li><li><strong>高阶函数 Higher-Order Function</strong> - 可以接受一个或多个函数作为输入参数，或者返回一个函数的函数。</li><li><strong>函数组合 Function Composition</strong> - 将多个小函数组合成一个新的函数，使得每个函数的输出作为下一个函数的输入</li><li><strong>函数柯里化 Function Currying</strong> - 将一个多参数函数转化为一系列单参数函数的技术。将一个接收多个参数的函数，转化为每次只接收一个参数的函数，并返回接收下一个参数的函数，直到所有参数都被提供完毕。</li><li><strong>惰性求值 Lazy Evaluation</strong> - 在需要结果时才计算，避免不必要的计算，提升效率。</li><li><strong>递归 Recursion</strong> - 函数直接或间接调用自身，常用于替代迭代过程。PS. 递归太多可能会发生 <strong>stack overflow</strong> 栈溢出，或&quot;爆栈&quot;，常见的解决方式是<strong>尾递归</strong>，即递归放在函数最后，编译器则会优化这一操作。</li><li><strong>声明式编程 Declarative Programming</strong> - 即描述&quot;做什么&quot;而不是&quot;怎么做&quot;，如 React 只需要描述组件的 UI 应该是什么样的，而不需要直接操作 DOM。</li></ul><h3 id="aop-面向切片编程" tabindex="-1">AOP 面向切片编程 <a class="header-anchor" href="#aop-面向切片编程" aria-label="Permalink to &quot;AOP 面向切片编程&quot;">​</a></h3><p>AOP 最广泛的应用是 <strong>Java Spring</strong> 框架。在前端最常见的是 <strong>Nestjs</strong> 框架，因为它就是参考 Spring 设计的。</p><h3 id="软件层级设计" tabindex="-1">软件层级设计 <a class="header-anchor" href="#软件层级设计" aria-label="Permalink to &quot;软件层级设计&quot;">​</a></h3><ul><li><strong>MVC</strong> - 它将应用程序分为三个主要部分：模型（Model）处理数据和逻辑，视图（View）显示用户界面，控制器（Controller）处理用户输入并更新模型和视图。</li><li><strong>MVP</strong> - 一种变种的设计模式，其中模型（Model）处理数据，视图（View）负责显示界面，演示者（Presenter）作为中介，接收用户输入并更新视图和模型。</li><li><strong>MVVM</strong> - 是一种设计模式，它将模型（Model）用于数据和业务逻辑，视图（View）用于显示用户界面，视图模型（ViewModel）通过数据绑定将模型数据转化为视图显示，通常在现代前端框架中使用。<strong>Vue</strong> 就是典型的 MVVM 设计方式。</li></ul><h2 id="前端基础" tabindex="-1">前端基础 <a class="header-anchor" href="#前端基础" aria-label="Permalink to &quot;前端基础&quot;">​</a></h2><h3 id="html" tabindex="-1">HTML <a class="header-anchor" href="#html" aria-label="Permalink to &quot;HTML&quot;">​</a></h3><ul><li><strong>Head 和 Meta</strong> - title、charset、link、script、style、keyword、description、author 等</li><li><strong>基础标签</strong> - div、h1、h2、h3、p、img、ul、ol、li、table 等</li><li><strong>表单</strong> - form、input、button、select 等</li><li><strong>媒体</strong> - video、audio 等</li><li><strong>2D 3D</strong> - SVG、Canvas 等</li></ul><h3 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h3><ul><li><strong>选择器</strong> - 标签、class、id、属性等</li><li><strong>图文样式</strong> - 字号、行高、颜色等</li><li><strong>布局</strong><ul><li>inline、block、inline-block</li><li>盒子模型</li><li>margin 相关：纵向合并，负 margin</li><li>flex 布局</li><li>grid 布局</li><li>float 布局</li><li>BFC</li></ul></li><li><strong>定位</strong><ul><li>relative</li><li>absolute</li><li>fixed</li><li>定位上下文</li></ul></li><li><strong>响应式</strong> - viewport、rem、vw、vh</li><li><strong>渐变和动画</strong> - transition、animation</li><li><strong>模块化</strong><ul><li>css module</li><li>css-in-js</li><li>BEM</li></ul></li><li><strong>第三方库</strong><ul><li>NormalizeCSS、ResetCSS</li><li>PostCSS</li><li>AnimateCSS、HoverCSS</li><li>TailwindCSS、BootStrap</li><li>Sass、Less、Stylus</li><li><a href="http://caniuse.com" target="_blank" rel="noreferrer">http://caniuse.com</a> 检测浏览器兼容性</li></ul></li></ul><h3 id="js-和-es" tabindex="-1">JS 和 ES <a class="header-anchor" href="#js-和-es" aria-label="Permalink to &quot;JS 和 ES&quot;">​</a></h3><h4 id="变量和类型" tabindex="-1">变量和类型 <a class="header-anchor" href="#变量和类型" aria-label="Permalink to &quot;变量和类型&quot;">​</a></h4><ul><li><strong>let const</strong></li><li><strong>undefined string number boolean object functioin symbol bigint</strong></li></ul><h4 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h4><ul><li><strong>字符串</strong></li><li><strong>数组</strong></li><li><strong>对象</strong></li><li><strong>函数</strong></li><li><strong>class</strong> - 原型，原型链，继承</li><li><strong>作用域</strong> - 作用链，自由变量，闭包</li><li><strong>异步</strong> - Promise、Async/await、微任务/宏任务、EventLoop</li><li><strong>Map 和 Set</strong></li><li><strong>Proxy 和 Reflect</strong></li><li><strong>Generator</strong> - * yield</li><li><strong>正则表达式</strong></li><li><strong>日期和时间</strong></li><li><strong>模块化</strong> - AMD、CMD、UMD、CommonJS、ES-Module</li><li><strong>异常处理</strong></li><li><strong>第三方库</strong> - lodash、jQuery、Axios、day.js、ECharts、D3、Anime.js、jsPDF、UUID、i18next ...</li></ul><h3 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h3>',28)),t[14]||(t[14]=o("ul",null,[o("li",null,[o("strong",null,"语法糖"),l(" - 本质是 JS 函数")]),o("li",{xxx:""},[o("strong",null,"插值和表达式"),l(" - 写法")]),o("li",{fn:""},[o("strong",null,"事件"),l(" - 写法 onClick=")]),o("li",null,[o("strong",null,"自定义组件"),l(" - 首字母大写")]),o("li",null,[o("strong",null,"注释"),l(" - {/* This is a comment */}")])],-1)),t[15]||(t[15]=i('<h3 id="ts" tabindex="-1">TS <a class="header-anchor" href="#ts" aria-label="Permalink to &quot;TS&quot;">​</a></h3><ul><li><strong>新增加的类型</strong> - any、void、never</li><li><strong>类型定义和检查</strong> - 变量，函数参数，函数返回值，class 等</li><li><strong>数组和元祖</strong></li><li><strong>Enum 枚举</strong></li><li><strong>自定义类型</strong> - type、交叉类型、联合类型</li><li><strong>接口</strong> - interface、接口的扩展和继承</li><li><strong>抽象类</strong> - Abstract class</li><li><strong>泛型</strong> - Generics</li><li><strong>装饰器</strong> - Decorator</li><li><strong>类型定义文件</strong> - .d.ts 安装第三方的如 npm install @types/lodash</li><li><strong>tsconfig.json 配置</strong></li></ul><h3 id="js-web-api" tabindex="-1">JS Web API <a class="header-anchor" href="#js-web-api" aria-label="Permalink to &quot;JS Web API&quot;">​</a></h3><ul><li><strong>DOM API</strong> - 查询、创建、修改、移动 DOM 节点，DOM 树，DocumentFragment</li><li><strong>DOM 事件</strong> - 事件绑定，事件冒泡，Event 参数，事件代理</li><li><strong>BOM API</strong> - window、navigator、screen、location、history 等</li><li><strong>存储</strong> - cookie、localStorage、sessionStorage、indexedDB</li><li><strong>Ajax</strong> - XMLHTTPRequest、fetch</li><li><strong>通讯</strong> - postMessage，BroadcastChannel</li><li><strong>WebWorker</strong> - 线程，sharedWorker，ServericeWorker，通讯</li><li><strong>jsbridge</strong> - 如微信 jssdk</li></ul><h2 id="网络-http-协议" tabindex="-1">网络 HTTP 协议 <a class="header-anchor" href="#网络-http-协议" aria-label="Permalink to &quot;网络 HTTP 协议&quot;">​</a></h2><ul><li><strong>URL 组成</strong></li><li><strong>Header</strong> - Content-type, Accept, Authorization, User-Agent, Host, Referer, Cookie, Cache-control, Content-length, Connection ...</li><li><strong>Method</strong> - GET, POST, PUT, DELETE, PATCH, RestfulAPI</li><li><strong>Request</strong> - url params body</li><li><strong>Response</strong> - status body set-cookie ...</li><li><strong>Status code</strong> - 10x 20x 30x 40x 50x</li><li><strong>cookie</strong> - 服务端 set-cookie，浏览器禁用第三方 cookie</li><li><strong>Session</strong> - 服务端存储数据</li><li><strong>JWT</strong> - 客户端存储数据，替换 token，OAuth 第三方登录，SSO 单点登录 ...</li><li><strong>跨域</strong> - 浏览器同源策略，JSONP，CORS，跨域传递 cookie</li><li><strong>浏览器缓存策略</strong><ul><li><strong>强制缓存</strong> - Cache-Control</li><li><strong>协商缓存</strong> - Etag，If-None-Match，Last-Modified， If-Modified-Since</li><li><strong>缓存位置</strong> - Memory Cache, Dist Cache, Service worker Cache</li></ul></li><li><strong>HTTPS</strong> - SSL 协议，SSL 证书，加密过程（非对称和对称加密），通讯过程，options 请求</li><li><strong>WebSocket</strong></li><li><strong>GraphQL</strong></li><li><strong>大文件上传</strong> - 切片上传，断点续传，秒传</li></ul>',6)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-1251",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20C%20as%20%E5%AE%A2%E6%88%B7%E7%AB%AF%0A%20%20%20%20participant%20S%20as%20%E6%9C%8D%E5%8A%A1%E5%99%A8%0A%0A%20%20%20%20Note%20over%20C%2CS%3A%20HTTP%20%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B%0A%0A%20%20%20%20C-%3E%3ES%3A%201.%20HTTP%20Request%0A%20%20%20%20Note%20right%20of%20C%3A%20Method%3A%20GET%2FPOST%3Cbr%2F%3EHeaders%3A%20Content-Type%2C%20Authorization%3Cbr%2F%3EBody%3A%20%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%0A%0A%20%20%20%20S-%3E%3ES%3A%202.%20%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%0A%20%20%20%20Note%20right%20of%20S%3A%20%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%3Cbr%2F%3E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%3Cbr%2F%3E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%0A%0A%20%20%20%20S-%3E%3EC%3A%203.%20HTTP%20Response%0A%20%20%20%20Note%20left%20of%20S%3A%20Status%20Code%3A%20200%2F404%2F500%3Cbr%2F%3EHeaders%3A%20Set-Cookie%2C%20Cache-Control%3Cbr%2F%3EBody%3A%20%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%0A%0A%20%20%20%20alt%20%E6%88%90%E5%8A%9F%E5%93%8D%E5%BA%94%0A%20%20%20%20%20%20%20%20C-%3E%3EC%3A%204a.%20%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%2F%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%0A%20%20%20%20else%20%E9%94%99%E8%AF%AF%E5%93%8D%E5%BA%94%0A%20%20%20%20%20%20%20%20C-%3E%3EC%3A%204b.%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%0A%20%20%20%20end%0A%0A%20%20%20%20Note%20over%20C%2CS%3A%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%0A%20%20%20%20C-%3E%3ES%3A%205.%20%E6%9D%A1%E4%BB%B6%E8%AF%B7%E6%B1%82%20(If-None-Match)%0A%20%20%20%20alt%20%E8%B5%84%E6%BA%90%E6%9C%AA%E5%8F%98%E5%8C%96%0A%20%20%20%20%20%20%20%20S-%3E%3EC%3A%20304%20Not%20Modified%0A%20%20%20%20else%20%E8%B5%84%E6%BA%90%E5%B7%B2%E5%8F%98%E5%8C%96%0A%20%20%20%20%20%20%20%20S-%3E%3EC%3A%20200%20OK%20%2B%20%E6%96%B0%E6%95%B0%E6%8D%AE%0A%20%20%20%20end%0A"})]),fallback:r(()=>[...t[5]||(t[5]=[l(" Loading... ",-1)])]),_:1})),t[16]||(t[16]=i('<h3 id="http-请求响应流程与缓存机制" tabindex="-1">HTTP 请求响应流程与缓存机制 <a class="header-anchor" href="#http-请求响应流程与缓存机制" aria-label="Permalink to &quot;HTTP 请求响应流程与缓存机制&quot;">​</a></h3><h2 id="服务端基础" tabindex="-1">服务端基础 <a class="header-anchor" href="#服务端基础" aria-label="Permalink to &quot;服务端基础&quot;">​</a></h2><p>服务端是一个很宽泛的概念，本文只讨论 JS 开发的服务端。</p><h3 id="js-运行时" tabindex="-1">JS 运行时 <a class="header-anchor" href="#js-运行时" aria-label="Permalink to &quot;JS 运行时&quot;">​</a></h3><ul><li><strong>Nodejs</strong> - 生态成熟，应用广泛</li><li><strong>Deno</strong> - 支持 TS，默认安全性，兼容 WebAPI</li><li><strong>Bun</strong> - 极致性能，All-in-one</li></ul><h3 id="nodejs-api" tabindex="-1">Nodejs API <a class="header-anchor" href="#nodejs-api" aria-label="Permalink to &quot;Nodejs API&quot;">​</a></h3><ul><li><strong>模块</strong> - CommonJS, ES-Module</li><li><strong>命令行</strong></li><li><strong>网络</strong> - HTTP HTTPS 服务</li><li><strong>文件</strong> - fs 读取、写入、创建、删除文件...</li><li><strong>流</strong> - stream readline</li><li><strong>进程</strong> - process</li><li><strong>集群</strong> - cluster PM2</li><li><strong>调试</strong> - debugger</li><li><strong>测试</strong></li></ul><h3 id="数据库" tabindex="-1">数据库 <a class="header-anchor" href="#数据库" aria-label="Permalink to &quot;数据库&quot;">​</a></h3><ul><li><strong>MySQL</strong> - 关系型数据库</li><li><strong>PostgreSQL</strong> - 关系型数据库</li><li><strong>MongoDB</strong> - No-SQL 数据库</li><li><strong>Redis</strong> - 内存数据库，速度快</li><li><strong>云数据库</strong> - Suspabase、Cloudflare 等</li></ul><h3 id="存储" tabindex="-1">存储 <a class="header-anchor" href="#存储" aria-label="Permalink to &quot;存储&quot;">​</a></h3><ul><li><strong>阿里云 OSS</strong></li><li><strong>腾讯云 COS</strong></li><li><strong>亚马逊 S3</strong></li></ul><h3 id="云服务器" tabindex="-1">云服务器 <a class="header-anchor" href="#云服务器" aria-label="Permalink to &quot;云服务器&quot;">​</a></h3><p>各个云平台都有免费试用，或低价活动，如果是学习用，可以轮流&quot;薅羊毛&quot;。</p><ul><li><strong>Linux 登录</strong> - 创建账户</li><li><strong>Linux 基础命令</strong></li><li><strong>Vim 命令</strong></li><li><strong>Nginx 配置</strong></li><li><strong>安全组和防火墙</strong></li></ul><h3 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h3><ul><li><strong>镜像</strong> - Image</li><li><strong>容器</strong> - Container</li><li><strong>DockerFile</strong></li><li><strong>Docker Compose</strong></li><li><strong>DockerHub</strong></li></ul><h3 id="serverless" tabindex="-1">Serverless <a class="header-anchor" href="#serverless" aria-label="Permalink to &quot;Serverless&quot;">​</a></h3><ul><li><strong>阿里云 FC</strong> - 函数计算</li><li><strong>亚马逊 Lambda</strong></li><li><strong>其他中小型服务商</strong> - Vercel、Netlify、Railway、<a href="http://Fly.io" target="_blank" rel="noreferrer">http://Fly.io</a> 等</li></ul><h3 id="微服务" tabindex="-1">微服务 <a class="header-anchor" href="#微服务" aria-label="Permalink to &quot;微服务&quot;">​</a></h3><h2 id="框架-库" tabindex="-1">框架/库 <a class="header-anchor" href="#框架-库" aria-label="Permalink to &quot;框架/库&quot;">​</a></h2><h3 id="react-使用" tabindex="-1">React 使用 <a class="header-anchor" href="#react-使用" aria-label="Permalink to &quot;React 使用&quot;">​</a></h3><ul><li><strong>JSX 语法</strong> - 上文有介绍</li><li><strong>函数组件</strong> - Functional Component，纯函数，副作用，生命周期，组件通讯</li><li><strong>属性</strong> - Props</li><li><strong>状态</strong> - State 不可变数据，immer.js，&quot;合并&quot;更新，异步更新，表单受控组件</li><li><strong>Hooks</strong> - useState, useEffect, useRef, useContext ... 自定义 Hook, react-use</li><li><strong>Context</strong> - Provider, Consumer</li><li><strong>性能优化</strong> - useMemo, useCallback, React.memo, React compiler ....</li><li><strong>Suspense 和异步组件</strong></li><li><strong>报错</strong> - ErrorBoundary</li><li><strong>服务端组件</strong> - RSC 服务端渲染 SSR</li></ul><h3 id="react-原理" tabindex="-1">React 原理 <a class="header-anchor" href="#react-原理" aria-label="Permalink to &quot;React 原理&quot;">​</a></h3><ul><li><strong>Virtual DOM</strong> - React 使用的虚拟文档对象模型，通过对比更新来优化性能</li><li><strong>Diff 算法</strong> - 对比新旧 vdom 并更新真实 DOM</li><li><strong>Reconciliation</strong> - React 的更新算法，用于高效地比较虚拟 DOM 与旧虚拟 DOM 之间的差异，并决定最小化的更新操作</li><li><strong>React Fiber</strong> - React 16 引入的重写的渲染引擎，提供更高效的渲染机制</li><li><strong>React 合成事件</strong> - React 使用事件代理机制，将事件监听器挂载到根 DOM 节点上，而不是每个组件的 DOM 节点，减少了事件监听器的数量，提高了性能</li><li><strong>React Concurrency</strong> - 是 React 18 引入的一项重要特性，使用时间分片和任务调度，用于提升应用的响应性和性能</li><li><strong>React Batching Update</strong> - React 会对多次 state 更新进行批量处理，合并成一次更新，以减少不必要的重渲染和性能开销</li></ul><h3 id="react-生态" tabindex="-1">React 生态 <a class="header-anchor" href="#react-生态" aria-label="Permalink to &quot;React 生态&quot;">​</a></h3><ul><li><strong>框架</strong> - umijs, Next.js, Remix(react-router), Gatsby, React-Native</li><li><strong>UI 组件库</strong> - AntD, MUI, ShadcnUI</li><li><strong>状态管理</strong> - Redux, Zustand, MobX, Recoil</li><li><strong>CSS 样式解决方案</strong> - TailwindCSS, Styled-components</li><li><strong>表单和校验</strong> - Formik, React hook form</li><li><strong>数据获取</strong> - React Query, SWR, Apollo Client</li><li><strong>i18n</strong> - react-i18next</li><li><strong>测试</strong> - Jest, Reat testing library, Storybook</li></ul>',26)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-1610",class:"mermaid",graph:"mindmap%0A%20%20root))%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81((%0A%20%20%20%20%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%0A%20%20%20%20%20%20HTML%0A%20%20%20%20%20%20CSS%0A%20%20%20%20%20%20JavaScript%0A%20%20%20%20%20%20TypeScript%0A%20%20%20%20%E6%A1%86%E6%9E%B6%E5%BA%93%0A%20%20%20%20%20%20React%0A%20%20%20%20%20%20%20%20Next.js%0A%20%20%20%20%20%20%20%20Gatsby%0A%20%20%20%20%20%20%20%20Remix%0A%20%20%20%20%20%20Vue%0A%20%20%20%20%20%20%20%20Nuxt.js%0A%20%20%20%20%20%20%20%20VuePress%0A%20%20%20%20%20%20Angular%0A%20%20%20%20%20%20Svelte%0A%20%20%20%20%E5%B7%A5%E7%A8%8B%E5%8C%96%0A%20%20%20%20%20%20%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%0A%20%20%20%20%20%20%20%20Webpack%0A%20%20%20%20%20%20%20%20Vite%0A%20%20%20%20%20%20%20%20Rollup%0A%20%20%20%20%20%20%E7%BC%96%E8%AF%91%E5%99%A8%0A%20%20%20%20%20%20%20%20Babel%0A%20%20%20%20%20%20%20%20SWC%0A%20%20%20%20%20%20%20%20esbuild%0A%20%20%20%20%20%20CI%2FCD%0A%20%20%20%20%20%20%20%20GitHub%20Actions%0A%20%20%20%20%20%20%20%20Jenkins%0A%20%20%20%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%0A%20%20%20%20%20%20Redux%0A%20%20%20%20%20%20Zustand%0A%20%20%20%20%20%20MobX%0A%20%20%20%20%20%20Vuex%2FPinia%0A%20%20%20%20UI%20%E7%BB%84%E4%BB%B6%E5%BA%93%0A%20%20%20%20%20%20Ant%20Design%0A%20%20%20%20%20%20Material-UI%0A%20%20%20%20%20%20Element%20Plus%0A%20%20%20%20%20%20Chakra%20UI%0A%20%20%20%20%E6%B5%8B%E8%AF%95%0A%20%20%20%20%20%20Jest%0A%20%20%20%20%20%20Vitest%0A%20%20%20%20%20%20Cypress%0A%20%20%20%20%20%20Playwright%0A"})]),fallback:r(()=>[...t[6]||(t[6]=[l(" Loading... ",-1)])]),_:1})),t[17]||(t[17]=i('<h4 id="前端技术生态系统" tabindex="-1">前端技术生态系统 <a class="header-anchor" href="#前端技术生态系统" aria-label="Permalink to &quot;前端技术生态系统&quot;">​</a></h4><h3 id="vue-使用" tabindex="-1">Vue 使用 <a class="header-anchor" href="#vue-使用" aria-label="Permalink to &quot;Vue 使用&quot;">​</a></h3><ul><li><strong>脚手架</strong></li><li><strong>模板语法</strong> - 类和样式，条件渲染，列表渲染，事件绑定，指令</li><li><strong>响应式</strong> - ref，reactive，reactive 局限性</li><li><strong>Computed</strong></li><li><strong>watch watchEffect</strong></li><li><strong>表单和 v-model</strong></li><li><strong>组件</strong> - 生命周期，组件通讯，属性 props</li><li><strong>插槽</strong> - slot</li><li><strong>异步组件</strong></li><li><strong>动态组件</strong></li><li><strong>KeepAlive</strong></li><li><strong>组合式函数</strong> - Composable 自定义 Composable，vue-use</li><li><strong>Setup Script</strong></li></ul><h3 id="vue-原理" tabindex="-1">Vue 原理 <a class="header-anchor" href="#vue-原理" aria-label="Permalink to &quot;Vue 原理&quot;">​</a></h3><ul><li><strong>Virtual DOM</strong> - Vue 使用虚拟 DOM 来优化 DOM 操作，避免直接操作真实 DOM，从而提高性能</li><li><strong>Diff 算法</strong> - 对比新旧 vdom 并更新真实 DOM</li><li><strong>响应式原理</strong> - Vue 的核心特性之一，通过数据劫持（Object.defineProperty 或 Proxy）实现视图与数据的双向绑定</li><li><strong>模板编译</strong> - Vue 将模板（HTML）编译成渲染函数，并通过虚拟 DOM 渲染 UI。编译过程将模板转换为可执行的 JavaScript 代码</li><li><strong>异步渲染</strong> - NextTick</li></ul><h3 id="vue-生态" tabindex="-1">Vue 生态 <a class="header-anchor" href="#vue-生态" aria-label="Permalink to &quot;Vue 生态&quot;">​</a></h3><ul><li><strong>框架</strong> - Nuxt.js, VuePress</li><li><strong>路由</strong> - Vue-router</li><li><strong>UI 组件库</strong> - ElementPlus, AntDesignVue, VantUI, Vuetify ...</li><li><strong>状态管理</strong> - Vuex, Pina</li><li><strong>i18n</strong> - vue-i18n</li><li><strong>测试</strong> - Vitest, Vue-test-utils, StoryBook</li></ul><h3 id="其他前端框架-库" tabindex="-1">其他前端框架/库 <a class="header-anchor" href="#其他前端框架-库" aria-label="Permalink to &quot;其他前端框架/库&quot;">​</a></h3><ul><li><strong>Angular</strong> - 老牌全能框架</li><li><strong>Selvte</strong> - 无 vdom，编译时框架，轻量高效</li><li><strong>Solid</strong> - 无 vdom，响应式编程，高效渲染</li></ul><h3 id="node-服务端" tabindex="-1">Node 服务端 <a class="header-anchor" href="#node-服务端" aria-label="Permalink to &quot;Node 服务端&quot;">​</a></h3><ul><li><strong>Express</strong> - 老牌 Nodejs 服务端框架，简洁易用</li><li><strong>Koa</strong> - 由 Express 的原班人马开发，Koa 提供了更精简和灵活的 API，利用现代 JavaScript 特性如 async/await，目标是创建更小、更优雅的框架</li><li><strong>Egg</strong> - 由阿里巴巴开发，基于 Koa 构建的企业级框架，提供了完善的插件机制和企业级功能，适用于构建复杂和大规模的应用</li><li><strong>Nest.js</strong> - Nodejs 开发的 Spring 框架</li></ul><h3 id="node-服务端生态" tabindex="-1">Node 服务端生态 <a class="header-anchor" href="#node-服务端生态" aria-label="Permalink to &quot;Node 服务端生态&quot;">​</a></h3><ul><li><strong>数据库 ORM</strong> - Prisma、Drizzle</li><li><strong>Auth 校验</strong> - NextAuth</li><li><strong>tRPC</strong> - 通讯</li><li><strong>i18n</strong> - 多语言</li><li><strong>队列服务</strong> - RabbitMQ, Kafka</li><li><strong>缓存</strong></li><li><strong>日志</strong></li><li><strong>AI 服务</strong> - ChatGPT （对中国地区停止 API 服务），DeepSeek 等</li><li><strong>邮件服务</strong> - 各大邮箱网站都提供免费 SMTP 服务（会有限制）， resend 等付费服务商</li><li><strong>短信服务</strong> - 腾讯云，阿里云</li><li><strong>支付</strong> - 微信支付，支付宝，Stripe 想学习 Node 全栈生态，推荐我带队开发的 <strong>Node 全栈 AIGC 知识库项目 划水 AI</strong> &lt;www.huashuiAI.com&gt; 包括文档管理、富文本编辑、AI 智能写作、多人协同编辑等功能。复杂业务，真实上线，持续运维。 可免费加群围观，也可加入学习和参与开发。</li></ul><h2 id="小程序" tabindex="-1">小程序 <a class="header-anchor" href="#小程序" aria-label="Permalink to &quot;小程序&quot;">​</a></h2><ul><li><strong>框架</strong> - 如 uni-app、Taro、WePY，提供跨平台开发的工具和规范。</li><li><strong>组件化</strong> - 小程序开发采用组件化方式，开发者可以创建自定义组件，提高代码的重用性和可维护性。</li><li><strong>WXML</strong> - 小程序的标记语言，类似 HTML，用于定义页面的结构。</li><li><strong>WXCC</strong> - 小程序的样式表语言，类似于 CSS，用于为 WXML 页面设置样式。</li><li><strong>API</strong> - 小程序提供了大量的官方 API，如 微信支付、位置服务、分享功能等，供开发者在小程序中调用。</li><li><strong>小程序路由</strong> - 使用 wx.navigateTo、wx.redirectTo、wx.switchTab 等 API 进行页面导航，支持页面栈管理。</li><li><strong>小程序生命周期</strong> - 小程序的生命周期包括 onLaunch、onShow、onHide 等，开发者可以在不同的生命周期阶段执行相关操作。</li><li><strong>小程序云开发</strong> - 提供云函数、云数据库、云存储等后端服务，简化开发者后端处理，提升开发效率。</li><li><strong>发布和调试</strong> - 使用 微信开发者工具 进行本地调试和真机调试，确保小程序在各平台上正常运行，最终通过开发者工具上传并发布到微信平台。</li></ul><h2 id="移动端" tabindex="-1">移动端 <a class="header-anchor" href="#移动端" aria-label="Permalink to &quot;移动端&quot;">​</a></h2><ul><li><strong>React Native</strong> - 基于 React 的移动端框架。</li><li><strong>Weex</strong> - 阿里巴巴开发，基于 Vue 的移动端框架。不维护了。</li><li><strong>Flutter</strong> - Google 开发，使用 Dart 语言</li></ul><h2 id="pc-客户端" tabindex="-1">PC 客户端 <a class="header-anchor" href="#pc-客户端" aria-label="Permalink to &quot;PC 客户端&quot;">​</a></h2><ul><li><strong>Electron</strong> - 使用 HTML、CSS、JavaScript 开发跨平台桌面应用（支持 Windows、macOS 和 Linux）</li></ul><h2 id="微前端" tabindex="-1">微前端 <a class="header-anchor" href="#微前端" aria-label="Permalink to &quot;微前端&quot;">​</a></h2><ul><li><strong>Single-SPA</strong> - 是一个非常流行的微前端框架，允许多个前端框架（如 React、Vue、Angular 等）在同一个页面中并行运行。</li><li><strong>Qiankun</strong> - 是阿里巴巴开源的微前端框架，基于 Single-SPA 开发，提供了更多的功能封装和优化。</li><li><strong>Module Federation (webpack5)</strong> - 允许在运行时动态加载和共享模块。它可以帮助解决微前端中的共享库和组件的问题。</li></ul><h2 id="pwa" tabindex="-1">PWA <a class="header-anchor" href="#pwa" aria-label="Permalink to &quot;PWA&quot;">​</a></h2><h2 id="工程化" tabindex="-1">工程化 <a class="header-anchor" href="#工程化" aria-label="Permalink to &quot;工程化&quot;">​</a></h2><h3 id="代码库管理" tabindex="-1">代码库管理 <a class="header-anchor" href="#代码库管理" aria-label="Permalink to &quot;代码库管理&quot;">​</a></h3><ul><li><strong>Git</strong> - Github，Gitlab，git 命令，commits，pre-commit hook， Pull request</li><li><strong>Monorepo</strong> - 单个仓库中管理多个项目</li></ul><h3 id="脚手架" tabindex="-1">脚手架 <a class="header-anchor" href="#脚手架" aria-label="Permalink to &quot;脚手架&quot;">​</a></h3><ul><li><strong>react vue 等各个框架的 cli 工具</strong></li><li><strong>AI 生成代码工具</strong> - v0, bolt.new</li></ul><h3 id="打包工具" tabindex="-1">打包工具 <a class="header-anchor" href="#打包工具" aria-label="Permalink to &quot;打包工具&quot;">​</a></h3><ul><li><strong>Webpack</strong> - 老牌打包工具，使用广泛</li><li><strong>Vite</strong> - 使用 ES Module 开发环境启动快</li><li><strong>Parcel</strong> - 无需配置，开箱即用</li><li><strong>esbuild</strong> - 使用 Go 语言开发，速度快，综合性编译和打包工具</li><li><strong>Rspack</strong> - 同样使用 Go 语言开发，速度快，综合性编译和打包工具</li><li><strong>Turbopack</strong> - Vercel 公司使用 Rust 开发 JS 打包工具，用于 Next.js 项目，也可以独立使用</li><li><strong>Rollup</strong> - 老牌打包工具，使用 Tree-shaking 优化代码，Vite 内部使用</li><li><strong>Rolldown</strong> - 新工具，Rust 开发，Vite 内部使用</li></ul><h3 id="js-编译器" tabindex="-1">JS 编译器 <a class="header-anchor" href="#js-编译器" aria-label="Permalink to &quot;JS 编译器&quot;">​</a></h3><ul><li><strong>Babel</strong> - 老牌 JS 编译工具，使用广泛</li><li><strong>SWC</strong> - 使用 Rust 语言开发的 JS 编译器，速度是 Babel 的 20-70 倍（不同 CPU），而且原生支持 TS 和 JSX 语法，旨在替代 Babel 。Vite 内部使用的就是 SWC 。</li><li><strong>Respack</strong> - 使用 Go 语言开发，速度快，综合性编译和打包工具</li><li><strong>esbuild</strong> - 同样使用 Go 语言开发，速度快，综合性编译和打包工具</li></ul><h3 id="代码压缩" tabindex="-1">代码压缩 <a class="header-anchor" href="#代码压缩" aria-label="Permalink to &quot;代码压缩&quot;">​</a></h3><ul><li><strong>UglifyJS</strong> - 老牌 JS 压缩工具</li><li><strong>Terser</strong> - 基于 UglifyJS 源码开发的，支持 ES6 新语法，对 tree-shaking 也做了优化。</li></ul><p>很多 JS 编译和打包工具都集成了代码压缩功能，如 <strong>SWC</strong>、<strong>esbuild</strong></p><h3 id="css-处理" tabindex="-1">CSS 处理 <a class="header-anchor" href="#css-处理" aria-label="Permalink to &quot;CSS 处理&quot;">​</a></h3><ul><li><strong>Sass/SCSS</strong> - 是 CSS 的一种扩展，提供了变量、嵌套规则、混合宏（mixins）、继承等功能。SCSS 是 Sass 的语法扩展，兼容普通的 CSS 语法。</li><li><strong>Less</strong> - 是一个 CSS 预处理器，与 Sass 类似，提供了变量、函数、嵌套等功能，用来增强 CSS 的功能性。</li><li><strong>PostCSS</strong> - 是一个 JavaScript 工具，允许开发者使用插件对 CSS 进行处理和转换。PostCSS 本身是一个工具平台，通过插件实现不同的功能。</li><li><strong>Autoprefixer</strong> - 是 PostCSS 的一个插件，自动为 CSS 属性添加浏览器前缀。它基于 can-i-use 数据库，自动判断哪些属性需要添加前缀，并且在构建时进行处理。</li></ul><h3 id="编码规范和格式" tabindex="-1">编码规范和格式 <a class="header-anchor" href="#编码规范和格式" aria-label="Permalink to &quot;编码规范和格式&quot;">​</a></h3><ul><li><strong>eslint 规范</strong> - Recommended、Airbnb、Google、StandardJS</li><li><strong>prettier</strong></li></ul><h3 id="ci-cd" tabindex="-1">CI/CD <a class="header-anchor" href="#ci-cd" aria-label="Permalink to &quot;CI/CD&quot;">​</a></h3><ul><li><strong>Github Action</strong> - 是 GitHub 提供的持续集成和持续交付（CI/CD）平台，允许用户在代码仓库中定义自动化工作流，自动化构建、测试和部署过程</li><li><strong>Gitlab CI</strong> - 是 GitLab 提供的集成式 CI/CD 系统，允许开发者通过 .gitlab-ci.yml 配置文件自动化构建、测试和部署，并与 GitLab 仓库紧密集成。</li><li><strong>Jenkins</strong> - 持续集成/持续交付工具，用于自动化构建和测试。</li></ul><h3 id="开发环境" tabindex="-1">开发环境 <a class="header-anchor" href="#开发环境" aria-label="Permalink to &quot;开发环境&quot;">​</a></h3><h4 id="ide-编辑器" tabindex="-1">IDE 编辑器 <a class="header-anchor" href="#ide-编辑器" aria-label="Permalink to &quot;IDE 编辑器&quot;">​</a></h4><ul><li><strong>vscode</strong> - 可集成 github copilot 智能编码</li><li><strong>webstorm</strong></li><li><strong>Cursor</strong> - 集成 AI 智能编码，付费</li><li><strong>codepen</strong> - 在线 IDE</li><li><strong>stackblitz</strong> - 在线 IDE</li></ul><h4 id="调试" tabindex="-1">调试 <a class="header-anchor" href="#调试" aria-label="Permalink to &quot;调试&quot;">​</a></h4><ul><li><strong>debugger 和断点</strong></li><li><strong>chrome 控制台</strong> - Element, Console, Network, Performance, Memory ...</li></ul><h4 id="抓包" tabindex="-1">抓包 <a class="header-anchor" href="#抓包" aria-label="Permalink to &quot;抓包&quot;">​</a></h4><ul><li><strong>chrome 控制台</strong> - Network</li><li><strong>charles</strong></li><li><strong>fiddler</strong></li></ul><h4 id="mock" tabindex="-1">mock <a class="header-anchor" href="#mock" aria-label="Permalink to &quot;mock&quot;">​</a></h4><ul><li><strong>Mock.js</strong></li><li><strong>Mock 在线服务</strong></li></ul><h3 id="测试" tabindex="-1">测试 <a class="header-anchor" href="#测试" aria-label="Permalink to &quot;测试&quot;">​</a></h3><h4 id="单元测试" tabindex="-1">单元测试 <a class="header-anchor" href="#单元测试" aria-label="Permalink to &quot;单元测试&quot;">​</a></h4><ul><li><strong>Jest</strong> - 是一个广泛使用的 JavaScript 测试框架，提供了丰富的功能，如断言、模拟、快照测试和覆盖率报告，广泛应用于 React 项目的单元测试。</li><li><strong>Vitest</strong> - 是一个快速、轻量级的测试框架，兼容 Jest API，利用 Vite 构建工具进行高效的测试运行，适合现代前端开发和快速反馈的需求。</li><li><strong>React Testing Library</strong> - 与 Jest 配合使用，专注于通过用户交互测试组件行为，而不是内部实现，鼓励测试组件的可访问性和用户体验。</li><li><strong>Vue Test Utils</strong> - Vue 官方提供的测试工具，专门用于编写和运行 Vue 组件的单元测试，提供了诸如挂载组件、触发事件、访问组件实例等功能。</li></ul><h4 id="e2e-测试" tabindex="-1">E2E 测试 <a class="header-anchor" href="#e2e-测试" aria-label="Permalink to &quot;E2E 测试&quot;">​</a></h4><ul><li><strong>Cypress</strong> - 是一个端到端测试框架，专注于前端应用的自动化测试，提供快速、可靠的测试执行和调试功能。</li><li><strong>Playwright</strong> - 是一个跨浏览器自动化工具，支持 Chromium、WebKit 和 Firefox，适用于多浏览器端到端测试。</li><li><strong>Puppeteer</strong> - 是一个基于 Node.js 的库，用于控制 Chromium 浏览器进行自动化测试和网页抓取，适合进行浏览器操作和内容提取。</li></ul><h2 id="统计、监控、安全和优化" tabindex="-1">统计、监控、安全和优化 <a class="header-anchor" href="#统计、监控、安全和优化" aria-label="Permalink to &quot;统计、监控、安全和优化&quot;">​</a></h2><h3 id="统计和监控" tabindex="-1">统计和监控 <a class="header-anchor" href="#统计和监控" aria-label="Permalink to &quot;统计和监控&quot;">​</a></h3><ul><li><strong>百度统计</strong> - PV UV 等</li><li><strong>Sentry</strong> - 综合性的 APM 监控平台</li><li><strong>报错监控</strong></li><li><strong>性能统计和监控</strong></li></ul><h3 id="安全" tabindex="-1">安全 <a class="header-anchor" href="#安全" aria-label="Permalink to &quot;安全&quot;">​</a></h3><ul><li><strong>跨站脚本攻击 XSS</strong> - 攻击者通过注入恶意脚本代码到网页中，从而窃取用户信息或执行未授权操作</li><li><strong>跨站请求伪造 CSRF</strong> - 攻击者诱使用户在已经认证的站点上执行恶意操作，利用用户的认证信息发送不必要的请求</li><li><strong>SQL 注入</strong> - 通过将恶意的 SQL 查询代码注入到应用程序的数据库查询中，攻击者能够篡改数据库。</li></ul><h3 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h3><ul><li><strong>性能指标</strong> - Web vitals TTFB, FCP, LCP, FID, CLS, INP</li><li><strong>代码分割</strong> - 常用模块可以缓存</li><li><strong>懒加载</strong> - JS 懒加载，图片懒加载</li><li><strong>资源压缩</strong> - 代码，图片</li><li><strong>渲染优化</strong> - 减少页面渲染次数，避免不必要的 reflow 和 repaint</li><li><strong>CDN</strong></li><li><strong>Edge 边缘计算</strong></li></ul><h2 id="项目管理" tabindex="-1">项目管理 <a class="header-anchor" href="#项目管理" aria-label="Permalink to &quot;项目管理&quot;">​</a></h2><h3 id="项目角色" tabindex="-1">项目角色 <a class="header-anchor" href="#项目角色" aria-label="Permalink to &quot;项目角色&quot;">​</a></h3><ul><li><strong>Product Owner</strong> - 产品负责人</li><li><strong>Product Manager</strong> - 项目经理 负责整体项目的规划、进度管理、资源协调和风险控制</li><li><strong>FrontEnd Developer</strong> - 前端开发</li><li><strong>BackEnd Developer</strong> - 后端开发</li><li><strong>FullStack Developer</strong> - 全栈开发</li><li><strong>UI/UX Designer</strong> - UI/UX 设计师</li><li><strong>QA</strong> - 测试工程师</li></ul><h3 id="scrum-敏捷开发" tabindex="-1">Scrum 敏捷开发 <a class="header-anchor" href="#scrum-敏捷开发" aria-label="Permalink to &quot;Scrum 敏捷开发&quot;">​</a></h3><ul><li><strong>Sprint</strong> - Scrum 中的迭代周期，通常持续 1 到 4 周。在每个 Sprint 中，团队会完成一定数量的任务，并交付一个可用的产品增量。</li><li><strong>Backlog</strong> - 产品待办事项列表，包含所有待开发的功能、修复、改进等项，由产品负责人（Product Owner）管理和优先级排序。</li><li><strong>Daily Standup</strong> - 团队每天举行的短会议，通常 15 分钟，成员讨论各自的工作进展、遇到的障碍和接下来的工作计划。</li><li><strong>Sprint Review</strong> - Sprint 结束时，团队展示已完成的工作成果，和产品负责人、相关利益相关者一起评审进展并进行反馈。</li><li><strong>Sprint Retrospective</strong> - Sprint 结束后，团队反思整个过程，讨论哪些方面做得好、哪些需要改进，以便在下一个 Sprint 中提升团队效率和协作。</li></ul><h3 id="kanban-敏捷开发" tabindex="-1">kanban 敏捷开发 <a class="header-anchor" href="#kanban-敏捷开发" aria-label="Permalink to &quot;kanban 敏捷开发&quot;">​</a></h3><p>类似于 Scrum 但更加灵活，没有固定的周期和角色，适合持续快速的交付。</p><h3 id="软件研发过程" tabindex="-1">软件研发过程 <a class="header-anchor" href="#软件研发过程" aria-label="Permalink to &quot;软件研发过程&quot;">​</a></h3><ul><li><strong>需求评审和 UI 设计</strong></li><li><strong>技术方案设计</strong></li><li><strong>开发过程</strong>：编码、调试、单元测试、自测、写注释和文档、代码走查等</li><li><strong>联调</strong></li><li><strong>提测</strong></li><li><strong>上线</strong><ul><li><strong>全量</strong></li><li><strong>小流量（灰度）</strong></li><li><strong>ABTest</strong></li></ul></li></ul>',70)),(n(),a(g,null,{default:r(()=>[e(s,{id:"mermaid-2488",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5B%E9%9C%80%E6%B1%82%E8%AF%84%E5%AE%A1%5D%20--%3E%20B%5BUI%20%E8%AE%BE%E8%AE%A1%5D%0A%20%20%20%20B%20--%3E%20C%5B%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%5D%0A%20%20%20%20C%20--%3E%20D%5B%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%5D%0A%0A%20%20%20%20subgraph%20%22%E5%BC%80%E5%8F%91%E9%98%B6%E6%AE%B5%22%0A%20%20%20%20%20%20%20%20D1%5B%E7%BC%96%E7%A0%81%5D%0A%20%20%20%20%20%20%20%20D2%5B%E8%B0%83%E8%AF%95%5D%0A%20%20%20%20%20%20%20%20D3%5B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%5D%0A%20%20%20%20%20%20%20%20D4%5B%E8%87%AA%E6%B5%8B%5D%0A%20%20%20%20%20%20%20%20D5%5B%E4%BB%A3%E7%A0%81%E8%B5%B0%E6%9F%A5%5D%0A%20%20%20%20%20%20%20%20D1%20--%3E%20D2%20--%3E%20D3%20--%3E%20D4%20--%3E%20D5%0A%20%20%20%20end%0A%0A%20%20%20%20D%20--%3E%20E%5B%E8%81%94%E8%B0%83%5D%0A%20%20%20%20E%20--%3E%20F%5B%E6%8F%90%E6%B5%8B%5D%0A%20%20%20%20F%20--%3E%20G%7BQA%20%E6%B5%8B%E8%AF%95%7D%0A%20%20%20%20G%20--%3E%7C%E9%80%9A%E8%BF%87%7C%20H%5B%E4%B8%8A%E7%BA%BF%5D%0A%20%20%20%20G%20--%3E%7C%E4%B8%8D%E9%80%9A%E8%BF%87%7C%20D%0A%0A%20%20%20%20subgraph%20%22%E4%B8%8A%E7%BA%BF%E7%AD%96%E7%95%A5%22%0A%20%20%20%20%20%20%20%20H1%5B%E5%B0%8F%E6%B5%81%E9%87%8F%2F%E7%81%B0%E5%BA%A6%5D%0A%20%20%20%20%20%20%20%20H2%5BAB%20Test%5D%0A%20%20%20%20%20%20%20%20H3%5B%E5%85%A8%E9%87%8F%E4%B8%8A%E7%BA%BF%5D%0A%20%20%20%20%20%20%20%20H%20--%3E%20H1%20--%3E%20H2%20--%3E%20H3%0A%20%20%20%20end%0A%0A%20%20%20%20H3%20--%3E%20I%5B%E7%BA%BF%E4%B8%8A%E7%9B%91%E6%8E%A7%5D%0A%20%20%20%20I%20--%3E%20J%5B%E7%BB%B4%E6%8A%A4%E4%B8%8E%E8%BF%AD%E4%BB%A3%5D%0A%0A%20%20%20%20style%20A%20fill%3A%23e8f5e8%0A%20%20%20%20style%20D%20fill%3A%23fff3e0%0A%20%20%20%20style%20G%20fill%3A%23e1f5fe%0A%20%20%20%20style%20H%20fill%3A%23f3e5f5%0A%20%20%20%20style%20I%20fill%3A%23fce4ec%0A"})]),fallback:r(()=>[...t[7]||(t[7]=[l(" Loading... ",-1)])]),_:1})),t[18]||(t[18]=i('<h4 id="软件研发流程" tabindex="-1">软件研发流程 <a class="header-anchor" href="#软件研发流程" aria-label="Permalink to &quot;软件研发流程&quot;">​</a></h4><h3 id="项目管理工具" tabindex="-1">项目管理工具 <a class="header-anchor" href="#项目管理工具" aria-label="Permalink to &quot;项目管理工具&quot;">​</a></h3><ul><li><strong>任务管理</strong>：Jira, Github project</li><li><strong>问题管理</strong>：Github Issues</li><li><strong>知识库</strong>：语雀，Notion 等</li></ul><h2 id="非技术事项" tabindex="-1">非技术事项 <a class="header-anchor" href="#非技术事项" aria-label="Permalink to &quot;非技术事项&quot;">​</a></h2><ul><li><strong>持续学习</strong>，及时关注新技术</li><li><strong>独立思考</strong>，凡事考虑本质和价值，多问为什么</li><li><strong>低头做事，抬头看路</strong>，定期放空自己，闲下来</li><li><strong>时间管理</strong>，有目标性和计划性，写出 todos 不要忘了</li><li><strong>保持形象</strong>，可以个性但不能油腻，追求合适的衣服、鞋子和发型</li><li><strong>定期体检</strong>，爱护头发、颈椎、腰椎，健康饮食和作息</li></ul>',5))])}const P=A(d,[["render",c]]);export{p as __pageData,P as default};
