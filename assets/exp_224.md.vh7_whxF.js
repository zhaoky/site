import{_ as e,c as o,o as c,U as d}from"./chunks/framework.GT16iXyP.js";const s=JSON.parse('{"title":"BFC等Formatting Contexts浅析","description":"","frontmatter":{},"headers":[],"relativePath":"exp/224.md","filePath":"exp/224.md"}'),i={name:"exp/224.md"},l=d('<h1 id="bfc等formatting-contexts浅析" tabindex="-1">BFC等Formatting Contexts浅析 <a class="header-anchor" href="#bfc等formatting-contexts浅析" aria-label="Permalink to &quot;BFC等Formatting Contexts浅析&quot;">​</a></h1><h3 id="盒模型" tabindex="-1">盒模型 <a class="header-anchor" href="#盒模型" aria-label="Permalink to &quot;盒模型&quot;">​</a></h3><p><code>CSS</code> 盒模型描述了通过 <code>文档树中的元素</code> 以及相应的 <code>视觉格式化模型(visual formatting model)</code> 所生成的矩形盒子。</p><h3 id="什么是-bfc" tabindex="-1">什么是 BFC <a class="header-anchor" href="#什么是-bfc" aria-label="Permalink to &quot;什么是 BFC&quot;">​</a></h3><p><code>BFC(Block formatting context)</code> 直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有 <code>Block-level box</code> 参与，它规定了内部的 <code>Block-level Box</code> 如何布局，并且与这个区域外部毫不相干。同理，还有 <code>inline-level box，run-in box</code>。</p><h3 id="bfc-布局规则" tabindex="-1">BFC 布局规则 <a class="header-anchor" href="#bfc-布局规则" aria-label="Permalink to &quot;BFC 布局规则&quot;">​</a></h3><ul><li>内部的 <code>Box</code> 会在垂直方向，一个接一个地放置。</li><li><code>Box</code> 垂直方向的距离由 <code>margin</code> 决定。属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠。</li><li>每个元素的 <code>margin box</code> 的左边， 与包含块 <code>border box</code> 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li><code>BFC</code> 的区域不会与 <code>float box</code> 重叠。</li><li><code>BFC</code> 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 <code>BFC</code> 的高度时，浮动元素也参与计算。</li></ul><h3 id="哪些元素是-bfc" tabindex="-1">哪些元素是 BFC <a class="header-anchor" href="#哪些元素是-bfc" aria-label="Permalink to &quot;哪些元素是 BFC&quot;">​</a></h3><ul><li>根元素，即 <code>HTML</code> 元素</li><li><code>float</code> 属性不为 <code>none</code></li><li><code>position</code> 为 <code>absolute</code> 或 <code>fixed</code></li><li><code>display</code> 为 <code>inline-block, table-cell, table-caption, flex, inline-flex</code></li><li><code>overflow</code> 不为 <code>visible</code></li></ul><h3 id="bfc-有什么用" tabindex="-1">BFC 有什么用 <a class="header-anchor" href="#bfc-有什么用" aria-label="Permalink to &quot;BFC 有什么用&quot;">​</a></h3><ul><li>自适应两栏布局</li><li>清除内部浮动（如给父元素加 <code>overflow:hidden</code>）</li><li>分属于不同的 <code>BFC</code> 时可以阻止 <code>margin</code> 重叠</li></ul><h3 id="什么是-fc" tabindex="-1">什么是 FC <a class="header-anchor" href="#什么是-fc" aria-label="Permalink to &quot;什么是 FC&quot;">​</a></h3><p><code>FC</code> 的全称是：<code>Formatting Contexts</code>，是 <code>W3C CSS2.1</code> 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p><code>FC</code> 一共包含 <code>BFC、IFC、GFC、FFC</code> 四种类型。<code>CSS2.1</code> 规范中只有 <code>BFC、IFC。CSS3</code> 推出 <code>GFC、FFC</code> 两种新类型。</p><h3 id="ifc" tabindex="-1">IFC <a class="header-anchor" href="#ifc" aria-label="Permalink to &quot;IFC&quot;">​</a></h3><p><code>IFC(Inline Formatting Contexts)</code> 直译为&quot;内联格式化上下文&quot;，<code>IFC</code> 的 <code>line box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p><h4 id="ifc-特性" tabindex="-1">IFC 特性 <a class="header-anchor" href="#ifc-特性" aria-label="Permalink to &quot;IFC 特性&quot;">​</a></h4><ul><li><code>IFC</code> 中的 <code>line box</code> 一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 <code>IFC</code> 与与 <code>line box</code> 之间，使得 l<code>ine box</code> 宽度缩短。</li><li><code>IFC</code> 中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div</code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code>，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</li></ul><h4 id="ifc-作用" tabindex="-1">IFC 作用 <a class="header-anchor" href="#ifc-作用" aria-label="Permalink to &quot;IFC 作用&quot;">​</a></h4><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生 <code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li><li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align:middle</code>，其他行内元素则可以在此父元素下垂直居中。</li></ul><h3 id="gfc" tabindex="-1">GFC <a class="header-anchor" href="#gfc" aria-label="Permalink to &quot;GFC&quot;">​</a></h3><p><code>GFC(GridLayout Formatting Contexts)</code> 直译为&quot;网格布局格式化上下文&quot;，当为一个元素设置 <code>display</code> 值为 <code>grid</code> 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（<code>grid container</code>）上定义网格定义行（<code>grid definition rows</code>）和网格定义列（<code>grid definition columns</code>）属性各在网格项目（<code>grid item</code>）上定义网格行（<code>grid row</code>）和网格列（<code>grid columns</code>）为每一个网格项目（<code>grid item</code>）定义位置和空间。</p><p><code>GFC</code> 将改变传统的布局模式，他将让布局从一维布局变成了二维布局。简单的说，有了 <code>GFC</code> 之后，布局不再局限于单个维度了。这个时候你要实现类似九宫格，拼图之类的布局效果显得格外的容易。</p><h3 id="ffc" tabindex="-1">FFC <a class="header-anchor" href="#ffc" aria-label="Permalink to &quot;FFC&quot;">​</a></h3><p><code>FFC(Flex Formatting Contexts)</code> 直译为&quot;自适应格式化上下文&quot;，<code>display</code> 值为 <code>flex</code> 或者 <code>inline-flex</code> 的元素将会生成自适应容器<code>（flex container）</code>。</p><p><code>Flex Box</code> 由伸缩容器和伸缩项目组成。通过设置元素的 <code>display</code> 属性为 <code>flex</code> 或 <code>inline-flex</code> 可以得到一个伸缩容器。设置为 <code>flex</code> 的容器被渲染为一个块级元素，而设置为 <code>inline-flex</code> 的容器则渲染为一个行内元素。</p><p>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，<code>Flexbox</code> 定义了伸缩容器内伸缩项目该如何布局。</p><p>整体来说，<code>FFC</code> 与 <code>BFC</code> 有点儿类似，但仍有以下几点区别：</p><ul><li><code>Flexbox</code> 不支持 <code>::first-line</code> 和 <code>::first-letter</code> 这两种伪元素</li><li><code>vertical-align</code> 对 <code>Flexbox</code> 中的子元素是没有效果的</li><li><code>float</code> 和 <code>clear</code> 属性对 <code>Flexbox</code> 中的子元素是没有效果的，也不会使子元素脱离文档流(但是对 <code>Flexbox</code> 是有效果的！)</li><li>多栏布局（<code>column-*</code>） 在 <code>Flexbox</code> 中也是失效的，就是说我们不能使用多栏布局在 <code>Flexbox</code> 排列其下的子元素</li><li><code>Flexbox</code> 下的子元素不会继承父级容器的宽</li></ul>',29),a=[l];function t(n,r,F,x,f,C){return c(),o("div",null,a)}const b=e(i,[["render",t]]);export{s as __pageData,b as default};
