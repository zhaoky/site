import{_ as i,c as a,o as l,R as n}from"./chunks/framework.Dxoqk0BT.js";const g=JSON.parse('{"title":"single-spa 与 qiankun","description":"","frontmatter":{},"headers":[],"relativePath":"micro/5.md","filePath":"micro/5.md"}'),e={name:"micro/5.md"};function o(s,t,r,d,p,c){return l(),a("div",null,[...t[0]||(t[0]=[n(`<h1 id="single-spa-与-qiankun" tabindex="-1">single-spa 与 qiankun <a class="header-anchor" href="#single-spa-与-qiankun" aria-label="Permalink to &quot;single-spa 与 qiankun&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>在微前端生态中,<strong>single-spa</strong> 是最早的开源微前端框架之一,而 <strong>qiankun</strong> 则是基于 single-spa 封装的企业级微前端解决方案。本文将深入分析两者的核心机制、优缺点以及技术演进。</p><h2 id="single-spa-核心机制" tabindex="-1">single-spa 核心机制 <a class="header-anchor" href="#single-spa-核心机制" aria-label="Permalink to &quot;single-spa 核心机制&quot;">​</a></h2><p>single-spa 的核心功能非常精简,主要完成两项工作:</p><ol><li><strong>加载微应用</strong> - 通过用户提供的加载函数动态加载子应用</li><li><strong>维护应用生命周期</strong> - 管理微应用的初始化(bootstrap)、挂载(mount)和卸载(unmount)状态</li></ol><p>虽然 single-spa 提供了微前端的基础能力,但在实际生产环境中暴露出诸多局限性。</p><h2 id="single-spa-的核心问题" tabindex="-1">single-spa 的核心问题 <a class="header-anchor" href="#single-spa-的核心问题" aria-label="Permalink to &quot;single-spa 的核心问题&quot;">​</a></h2><h3 id="_1-对微应用的强侵入性" tabindex="-1">1. 对微应用的强侵入性 <a class="header-anchor" href="#_1-对微应用的强侵入性" aria-label="Permalink to &quot;1. 对微应用的强侵入性&quot;">​</a></h3><p>single-spa 采用 <strong>JS Entry</strong> 方式接入微应用,需要对现有项目进行较大改造:</p><ul><li><strong>路由改造</strong> - 为微应用路由添加特定前缀,避免路由冲突</li><li><strong>入口改造</strong> - 修改应用挂载点,导出标准生命周期函数(<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>)</li><li><strong>构建配置调整</strong> - 修改 webpack 等打包工具配置</li></ul><h3 id="_2-构建产物限制与性能问题" tabindex="-1">2. 构建产物限制与性能问题 <a class="header-anchor" href="#_2-构建产物限制与性能问题" aria-label="Permalink to &quot;2. 构建产物限制与性能问题&quot;">​</a></h3><p>JS Entry 方式要求将整个微应用打包成<strong>单个 JS 文件</strong>,这带来了严重的性能问题:</p><p><strong>失去的优化能力:</strong></p><ul><li>❌ 代码分割(Code Splitting)和按需加载</li><li>❌ 首屏资源加载优化</li><li>❌ CSS 独立提取与并行加载</li><li>❌ 静态资源 CDN 缓存优化</li></ul><p><strong>版本更新的连锁反应:</strong></p><p>当微应用修复 bug 并重新发布时,由于文件名包含 hash 值(如 <code>app.[contenthash].js</code>)会发生变化,导致:</p><ol><li>微应用构建产物文件名改变</li><li>主应用配置中的微应用 JS 地址需要手动更新</li><li>主应用需要重新编译和发布</li></ol><p>这种<strong>强耦合的发布流程</strong>在大型系统中难以接受,严重影响开发效率。</p><h3 id="_3-样式隔离缺失" tabindex="-1">3. 样式隔离缺失 <a class="header-anchor" href="#_3-样式隔离缺失" aria-label="Permalink to &quot;3. 样式隔离缺失&quot;">​</a></h3><p>single-spa <strong>未提供任何样式隔离机制</strong>,在多微应用系统中容易出现样式冲突:</p><ul><li>微应用之间的样式相互污染</li><li>微应用与主应用的样式相互影响</li></ul><p><strong>现有解决方案的局限:</strong></p><ul><li>只能通过<strong>约定式命名规范</strong>(如 BEM、CSS Modules)来规避</li><li>对于已有的大型系统,改造成本极高</li><li>无法从技术层面彻底解决问题</li></ul><h3 id="_4-javascript-沙箱隔离缺失" tabindex="-1">4. JavaScript 沙箱隔离缺失 <a class="header-anchor" href="#_4-javascript-沙箱隔离缺失" aria-label="Permalink to &quot;4. JavaScript 沙箱隔离缺失&quot;">​</a></h3><p>single-spa <strong>未实现 JS 运行时隔离</strong>,导致全局对象污染问题:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 微应用 A</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.userInfo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;App A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 切换到微应用 B 后,window.userInfo 依然存在</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可能导致数据混乱或冲突</span></span></code></pre></div><p><strong>潜在风险:</strong></p><ul><li>全局变量污染(<code>window</code>、<code>document</code> 等)</li><li>全局事件监听器未清理</li><li>定时器、异步任务泄漏</li></ul><h3 id="_5-资源预加载能力缺失" tabindex="-1">5. 资源预加载能力缺失 <a class="header-anchor" href="#_5-资源预加载能力缺失" aria-label="Permalink to &quot;5. 资源预加载能力缺失&quot;">​</a></h3><p>single-spa 不支持微应用资源的<strong>预加载(Prefetch)</strong>,无法实现:</p><ul><li>在空闲时间预加载其他微应用资源</li><li>提升应用切换的流畅度</li><li>优化用户体验</li></ul><h3 id="_6-应用间通信机制缺失" tabindex="-1">6. 应用间通信机制缺失 <a class="header-anchor" href="#_6-应用间通信机制缺失" aria-label="Permalink to &quot;6. 应用间通信机制缺失&quot;">​</a></h3><p>single-spa 仅在注册时向微应用注入少量状态信息,<strong>不提供应用间通信能力</strong>:</p><ul><li>无内置的消息总线或事件系统</li><li>需要开发者自行实现通信方案(如 <code>CustomEvent</code>、发布订阅模式等)</li></ul><hr><h2 id="qiankun-的技术革新" tabindex="-1">qiankun 的技术革新 <a class="header-anchor" href="#qiankun-的技术革新" aria-label="Permalink to &quot;qiankun 的技术革新&quot;">​</a></h2><h3 id="html-entry-方案" tabindex="-1">HTML Entry 方案 <a class="header-anchor" href="#html-entry-方案" aria-label="Permalink to &quot;HTML Entry 方案&quot;">​</a></h3><p>为了解决 single-spa 的 JS Entry 痛点,<strong>qiankun</strong> 采用了 <strong>HTML Entry</strong> 方案,让微应用接入像使用 <code>&lt;iframe&gt;</code> 一样简单。</p><h3 id="import-html-entry-核心原理" tabindex="-1">import-html-entry 核心原理 <a class="header-anchor" href="#import-html-entry-核心原理" aria-label="Permalink to &quot;import-html-entry 核心原理&quot;">​</a></h3><p>qiankun 依赖 <code>import-html-entry</code> 库实现 HTML Entry,其工作流程如下:</p><ol><li><p><strong>加载 HTML 模板</strong> 通过 HTTP 请求获取微应用的 <code>index.html</code> 内容</p></li><li><p><strong>解析 HTML 结构</strong> 提取关键信息:</p><ul><li><code>template</code> - HTML 模板结构</li><li><code>scripts</code> - 所有 <code>&lt;script&gt;</code> 标签的 URL 和内容</li><li><code>styles</code> - 所有 <code>&lt;link&gt;</code> 和 <code>&lt;style&gt;</code> 的样式内容</li><li><code>entry</code> - 入口脚本地址</li></ul></li><li><p><strong>处理样式资源</strong></p><ul><li>远程加载 <code>&lt;link&gt;</code> 引用的 CSS 文件</li><li>将外链样式转换为内联 <code>&lt;style&gt;</code> 标签</li><li>替换模板中的样式占位符</li></ul></li><li><p><strong>返回可执行对象</strong> 向外暴露一个 Promise,resolve 后包含:</p><ul><li><code>template</code> - 处理后的 HTML 模板</li><li><code>assetPublicPath</code> - 资源公共路径</li><li><code>execScripts</code> - 脚本执行函数</li></ul></li></ol><h3 id="qiankun-的集成与增强" tabindex="-1">qiankun 的集成与增强 <a class="header-anchor" href="#qiankun-的集成与增强" aria-label="Permalink to &quot;qiankun 的集成与增强&quot;">​</a></h3><p>qiankun 基于 <code>import-html-entry</code> 返回的对象,实现了完整的微前端能力:</p><p><strong>核心流程:</strong></p><ol><li><p><strong>挂载模板</strong> 将 <code>template</code> 通过 DOM 操作插入主应用的容器节点</p></li><li><p><strong>执行脚本并获取生命周期</strong> 调用 <code>execScripts()</code> 方法:</p><ul><li>在沙箱环境中执行微应用的 JS 代码</li><li>获取微应用导出的生命周期钩子(<code>bootstrap</code>、<code>mount</code>、<code>unmount</code>)</li></ul></li><li><p><strong>JavaScript 沙箱隔离</strong> 通过 <code>execScripts</code> 的 <code>proxy</code> 参数指定 JS 执行上下文:</p><ul><li><strong>快照沙箱</strong>(SnapshotSandbox) - 单实例场景</li><li><strong>代理沙箱</strong>(ProxySandbox) - 多实例场景,基于 Proxy 实现</li></ul></li></ol><p><strong>qiankun 的核心优势:</strong></p><ul><li>✅ <strong>零侵入接入</strong> - 微应用无需打包成单文件</li><li>✅ <strong>样式隔离</strong> - 支持 Shadow DOM 或作用域 CSS</li><li>✅ <strong>JS 沙箱</strong> - 自动隔离全局变量和副作用</li><li>✅ <strong>资源预加载</strong> - 内置 prefetch 能力</li><li>✅ <strong>应用通信</strong> - 提供 <code>initGlobalState</code> 全局状态管理</li></ul><hr><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><table><thead><tr><th>特性</th><th>single-spa</th><th>qiankun</th></tr></thead><tbody><tr><td>接入方式</td><td>JS Entry</td><td>HTML Entry</td></tr><tr><td>样式隔离</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>JS 沙箱</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>资源预加载</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>应用通信</td><td>❌ 需自行实现</td><td>✅ 内置方案</td></tr><tr><td>侵入性</td><td>高</td><td>低</td></tr><tr><td>生产可用性</td><td>需大量定制</td><td>开箱即用</td></tr></tbody></table><p>qiankun 在 single-spa 的基础上,通过 HTML Entry 和完善的沙箱机制,真正实现了<strong>生产级微前端解决方案</strong>,是目前企业应用的主流选择之一。</p>`,52)])])}const u=i(e,[["render",o]]);export{g as __pageData,u as default};
