import{_ as e,c as o,o as c,U as d}from"./chunks/framework.7BZ-Q4AH.js";const k=JSON.parse('{"title":"源码分析（十四）：webpack 优化","description":"","frontmatter":{},"headers":[],"relativePath":"code/webpack4/385.md","filePath":"code/webpack4/385.md"}'),i={name:"code/webpack4/385.md"},l=d('<h1 id="源码分析-十四-webpack-优化" tabindex="-1">源码分析（十四）：webpack 优化 <a class="header-anchor" href="#源码分析-十四-webpack-优化" aria-label="Permalink to &quot;源码分析（十四）：webpack 优化&quot;">​</a></h1><p>前面一至十一章，介绍了在 <code>development</code> 的模式下，整个完整了构建主流程。在了解构建流程的基础上，本章整理一些与 <code>webpack</code> 优化相关的知识点。</p><h2 id="production-模式" tabindex="-1">production 模式 <a class="header-anchor" href="#production-模式" aria-label="Permalink to &quot;production 模式&quot;">​</a></h2><p>我们参考 <code>production</code> 模式里，里面已经做了大部分的优化，如压缩，<code>Scope Hoisting</code>， <code>tree-shaking</code> 等都给予了我们启发，接下来具体分析各个点。</p><h3 id="production-模式启用的插件" tabindex="-1">production 模式启用的插件 <a class="header-anchor" href="#production-模式启用的插件" aria-label="Permalink to &quot;production 模式启用的插件&quot;">​</a></h3><ul><li><code>FlagDependencyUsagePlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeDependencies</code></li><li>功能：标记模块导出中被使用的导出，存在 <code>module.usedExports</code> 里。用于 <code>Tree shaking</code>。</li><li>对应配置项：<code>optimization.usedExports:true</code></li></ul></li><li><code>FlagIncludedChunksPlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeChunkId</code></li><li>功能：给每个 <code>chunk</code> 添加了 <code>ids</code>，用于判断避免加载不必要的 <code>chunk</code></li></ul></li><li><code>ModuleConcatenationPlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeChunkModules</code></li><li>功能：使用 <code>esm</code> 语法可以作用域提升(<code>Scope Hoisting</code>)或预编译所有模块到一个闭包中，提升代码在浏览器中的执行速度</li><li>对应配置项：<code>optimization.concatenateModules:true</code></li></ul></li><li><code>NoEmitOnErrorsPlugin</code><ul><li>触发时机：<code>compiler.hooks.shouldEmit</code>，<code>compilation.hooks.shouldRecord</code></li><li>功能：如果在 <code>compilation</code> 编译时有 <code>error</code>，则不执行 <code>Record</code> 相关的钩子，并且抛错和不编译资源</li></ul></li><li><code>OccurrenceOrderModuleIdsPlugin</code>，<code>OccurrenceOrderChunkIdsPlugin</code><ul><li>注意不是<a href="https://webpack.js.org/configuration/mode/#root" target="_blank" rel="noreferrer">文档</a>写的 <code>OccurrenceOrderPlugin</code>，这个没用</li><li>触发时机：<code>compilation.hooks.optimizeModuleOrder</code>，<code>compilation.hooks.optimizeChunkOrder</code></li><li>功能：根据模块初始调用次数或者总调用次数排序（<a href="https://webpack.docschina.org/configuration/optimization/#optimization-moduleids" target="_blank" rel="noreferrer">配置</a>），这样在后面分配 <code>ID</code> 的时候常被调用 <code>ID</code> 就靠前，除此之外，还可以让 <code>id</code> 为路径，<code>hash</code> 等。</li><li>对应配置项：<code>optimization.occurrenceOrder</code>，<code>optimization.chunkIds</code>，<code>optimization.moduleIds</code></li></ul></li><li><code>SideEffectsFlagPlugin</code><ul><li>触发时机：<code>normalModuleFactory.hooks.module</code>，<code>compilation.hooks.optimizeDependencies</code></li><li>功能： <ul><li><code>normalModuleFactory.hooks.module</code> 钩子里读取 <code>package.json</code> 里的 <code>sideEffects</code> 字段和读取 <code>module.rule</code> 里的 <code>sideEffects</code> 赋给 <code>module.factoryMeta</code>（纯的 <code>ES2015</code> 模块)；</li><li><code>compilation.hooks.optimizeDependencies</code> 钩子里根据 <code>sideEffects</code> 配置，删除未用到的 <code>export</code> 导出</li></ul></li><li>对应配置项：<code>optimization.sideEffects:true</code>（默认）</li></ul></li><li><code>TerserPlugin</code><ul><li>触发时机：<code>template.hooks.hashForChunk</code>，<code>compilation.hooks.optimizeChunkAssets</code></li><li>功能： <ul><li>在 <code>template.hooks.hashForChunk</code> 钩子即在 <code>chunks</code> 生成 <code>hash</code> 阶段会把压缩相关的信息也打入到里面</li><li>在 <code>compilation.hooks.optimizeChunkAssets</code> 钩子触发资源压缩事件</li></ul></li><li>对应配置项： <ul><li><code>optimization.minimize</code> 是否开启压缩</li><li><code>optimization.minimizer</code> 定制 <code>Terser</code>，默认开启多进程压缩和缓存</li></ul></li></ul></li></ul><p>另：<code>development</code> 模式单独启用的插件：</p><ul><li><code>NamedChunksPlugin</code><ul><li>触发时机：<code>compilation.hooks.beforeChunkIds</code></li><li>功能：以名称固化 <code>chunk id</code></li><li>对应配置项：<code>optimization.chunkIds</code></li></ul></li><li><code>NamedModulesPlugin</code><ul><li>触发时机：<code>compilation.hooks.beforeModuleIds</code></li><li>功能：以名称固化 <code>module id</code></li><li>对应配置项：<code>optimization.moduleIds</code></li></ul></li></ul><h2 id="持久化缓存" tabindex="-1">持久化缓存 <a class="header-anchor" href="#持久化缓存" aria-label="Permalink to &quot;持久化缓存&quot;">​</a></h2><blockquote><p>在更新部署页面资源时，无论是先部署页面，还是先部署其他静态资源，都会因为新老资源替换后的缓存原因，或者部署间隔原因，都会导致资源不对应而引起页面错误。</p></blockquote><p>持久化缓存方案就是在各静态资源的名字后面加唯一的 <code>hash</code> 值，这样在每次修改文件后生成的不同的 <code>hash</code> 值，然后在增量式发布文件时，就可以避免覆盖掉之前旧的文件。获取到新文件的用户就可以访问新的资源，而浏览器有缓存等情况的用户则继续访问老资源，保证新老资源同时存在且互不影响不出错。</p><ul><li>对于 <code>html</code>：不开启缓存，把 <code>html</code> 放到单独的服务器上并关闭服务器的缓存，需要保证每次的 <code>html</code> 都为最新</li><li>对于 <code>js</code>，<code>css</code>，<code>img</code> 等其他静态资源：开启缓存，将静态资源上传到 <code>cdn</code>，对资源开启长期缓存，因为有唯一 <code>hash</code> 的缘故所以不会导致资源被覆盖，用户在初次访问可以将这些长效缓存下载到本地，然后在后续的访问可以直接从缓存里读，节约网络资源。</li></ul><h3 id="webpack-中的持久化缓存" tabindex="-1">webpack 中的持久化缓存 <a class="header-anchor" href="#webpack-中的持久化缓存" aria-label="Permalink to &quot;webpack 中的持久化缓存&quot;">​</a></h3><ul><li>对 <code>js</code> 使用 <code>chunkhash</code> ，对 <code>css</code> 应用 <code>mini-css-extract-plugin</code> 插件并使用 <code>contenthash</code></li><li>通过 <code>optimization.moduleIds</code> 属性设置 <code>module id</code><ul><li>开发环境 <code>moduleIds</code> 设为 <code>named</code> 即使用 <code>NamedModulesPlugin</code> （相对路径为 <code>key</code>）来固化 <code>module id</code>，</li><li>生产环境 <code>moduleIds</code> 设为 <code>hashed</code> 即使用 <code>HashedModuleIdsPlugin</code> （将路径转换为 <code>hash</code> 为 <code>key</code>）来固化 <code>module id</code>，保证在某一模块增删后，不会影响其他模块的 <code>module id</code></li></ul></li><li>通过 <code>optimization.chunkIds</code> 属性设置为 <code>named</code> 或 <code>optimization.namedChunks</code> 属性设置为 <code>true</code> （通过将 <code>chunk name</code> 复制到 <code>chunk id</code>）固化 <code>chunk id</code>，该属性会启用 <code>NamedChunksPlugin</code><ul><li><code>NamedChunksPlugin</code> 插件里可以自定义 <code>nameResolver</code> 设置 <code>name</code></li><li><code>splitChunks.cacheGroups[].name</code> 也可以设置 <code>chunk name</code></li><li><a href="https://webpack.js.org/api/module-methods/#magic-comments" target="_blank" rel="noreferrer">魔法注释</a>也可以设置：<code>import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &#39;module&#39;)</code></li></ul></li><li>通过 <code>optimization.splitChunks</code> 属性抽离库 <code>vendor</code>，业务公共代码 <code>common</code></li><li>通过 <code>optimization.runtimeChunk</code> 属性抽离运行时 <code>runtime</code>，其中 <code>runtime</code> 也可以通过 <code>script-ext-html-webpack-plugin</code> 插件嵌入到 <code>html</code></li></ul><h2 id="tree-sharing" tabindex="-1">Tree Sharing <a class="header-anchor" href="#tree-sharing" aria-label="Permalink to &quot;Tree Sharing&quot;">​</a></h2><p><code>Tree Sharing</code> 是一个术语，通常用于描述移除 <code>JavaScript</code> 上下文中的未引用代码(<code>dead-code</code>)。由 <a href="https://rollupjs.org/guide/en/" target="_blank" rel="noreferrer">rollup</a> 普及，在 <code>webpack</code> 里由 <code>TerserPlugin</code> 实现。</p><h3 id="tree-sharing-原理" tabindex="-1">tree-sharing 原理 <a class="header-anchor" href="#tree-sharing-原理" aria-label="Permalink to &quot;tree-sharing 原理&quot;">​</a></h3><ul><li><code>ES6</code> 的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码</li><li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li></ul><p>如果我们引入的模块被标记为 <code>sideEffects: false</code>，只要它任意一个导出都没有被其他模块引用到，那么不管它是否真的有副作用，整个模块都会被完整的移除。</p><blockquote><p>&quot;<code>side effect</code>(副作用)&quot; 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 <code>export</code> 或多个 <code>export</code>。举例说明，例如 <code>polyfill</code>，它影响全局作用域，并且通常不提供 <code>export</code>。</p></blockquote><h3 id="启用-tree-shaking-需要满足" tabindex="-1">启用 <code>tree shaking</code> 需要满足 <a class="header-anchor" href="#启用-tree-shaking-需要满足" aria-label="Permalink to &quot;启用 `tree shaking` 需要满足&quot;">​</a></h3><ul><li>使用 <code>ES2015</code> 模块语法（即 <code>import</code> 和 <code>export</code>），目的是为了供程序静态分析</li><li>确保没有 <code>compiler</code> 将 <code>ES2015</code> 模块语法转换为 <code>CommonJS</code> 模块（设置 <code>babel.config.js</code> <code>presets: [[&#39;@babel/env&#39;, { modules: false }]]</code>）</li><li>在 <code>package.json</code> 或者 <code>module.rule</code> 设置 <code>sideEffects : false</code>，告诉 <code>webpack</code> 该项目或者该文件没有副作用</li><li>mode 选项设置为 <code>production</code>，其中会启用 <code>FlagDependencyUsagePlugin</code>，<code>TerserPlugin</code> 完成 <code>tree shaking</code></li></ul><h2 id="scope-hoisting" tabindex="-1">Scope Hoisting <a class="header-anchor" href="#scope-hoisting" aria-label="Permalink to &quot;Scope Hoisting&quot;">​</a></h2><p><code>Scope Hoisting</code> 即 作用域提升，可以让 <code>webpack</code> 打包出来的代码文件更小，运行更快。</p><h3 id="scope-hoisting-优点" tabindex="-1">Scope Hoisting 优点 <a class="header-anchor" href="#scope-hoisting-优点" aria-label="Permalink to &quot;Scope Hoisting 优点&quot;">​</a></h3><ul><li>代码体积会变小，因为函数声明语句会产生大量代码</li><li>代码在运行时因为创建的函数作用域减少了，内存开销也随之变小</li></ul><h3 id="scope-hoisting-原理" tabindex="-1">Scope Hoisting 原理 <a class="header-anchor" href="#scope-hoisting-原理" aria-label="Permalink to &quot;Scope Hoisting 原理&quot;">​</a></h3><p><code>ES6</code> 的静态模块分析，分析出模块之间的依赖关系，按照引用顺序尽可能地把模块放到同一个函数作用域中，然后适当的重命名一些变量以防止变量名冲突。</p><blockquote><p>异步 <code>import()</code> 不会启用 <code>Scope Hoisting</code></p></blockquote><h3 id="启用-scope-hoisting-需要满足" tabindex="-1">启用 Scope Hoisting 需要满足 <a class="header-anchor" href="#启用-scope-hoisting-需要满足" aria-label="Permalink to &quot;启用 Scope Hoisting 需要满足&quot;">​</a></h3><ul><li>使用 <code>ES2015</code> 模块语法（即 <code>import</code> 和 <code>export</code>）</li><li><code>mode</code> 选项设置为 <code>production</code>，其中会启用 <code>ModuleConcatenationPlugin</code> 插件完成 <code>Scope Hoisting</code></li></ul><h2 id="一些插件" tabindex="-1">一些插件 <a class="header-anchor" href="#一些插件" aria-label="Permalink to &quot;一些插件&quot;">​</a></h2><p>以下列举部分我用过优化相关的插件及 <code>loader</code>：</p><ol><li><a href="https://github.com/amireh/happypack" target="_blank" rel="noreferrer">happypack</a> 多线程编译，加快编译速度 注：已被废弃，使用 <a href="https://www.webpackjs.com/loaders/thread-loader/" target="_blank" rel="noreferrer">thread-loader</a></li><li><a href="https://github.com/nuxt/webpackbar" target="_blank" rel="noreferrer">webpackbar</a> 编译进度条</li><li><a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noreferrer">mini-css-extract-plugin</a> 提取 <code>css</code> 样式到单独文件</li><li><a href="https://github.com/numical/style-ext-html-webpack-plugin" target="_blank" rel="noreferrer">style-ext-html-webpack-plugin</a> 增强 <code>HtmlWebpackPlugin</code>，将 <code>css</code> 内联到 <code>html</code> 里</li><li><a href="https://github.com/numical/script-ext-html-webpack-plugin" target="_blank" rel="noreferrer">script-ext-html-webpack-plugin</a> 增强 <code>HtmlWebpackPlugin</code>，将 <code>js</code> 内联到 <code>html</code> 里</li><li><a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin" target="_blank" rel="noreferrer">optimize-css-assets-webpack-plugin</a> 使用<a href="http://github.com/ben-eb/cssnano" target="_blank" rel="noreferrer">cssnano</a>压缩优化 <code>css</code></li><li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="noreferrer">webpack-bundle-analyzer</a> 模块分析</li><li><a href="https://github.com/webpack-contrib/url-loader" target="_blank" rel="noreferrer">url-loader</a> 将文件转换为 <code>DataURL</code>，减少请求数</li><li><a href="https://github.com/stephencookdev/speed-measure-webpack-plugin" target="_blank" rel="noreferrer">speed-measure-webpack-plugin</a> 构建耗时分析</li></ol><p>各插件随着时间推移，有的可能废弃，有的可能被更好的所替代，已社区流行为准。</p><h2 id="一些其他优化点" tabindex="-1">一些其他优化点 <a class="header-anchor" href="#一些其他优化点" aria-label="Permalink to &quot;一些其他优化点&quot;">​</a></h2><ol><li>缓存二次构建，如 <code>babel-loader</code>，<code>terser-webpack-plugin</code> 开启缓存，使用 <code>cache-loader</code>，使用 <code>hard-source-webpack-plugin</code>(已被 <code>webpack5</code> 内置) 等</li><li>分包构建，如 <code>DLLPlugin+DllRefrencePlugin</code> 等</li><li>缩小构建范围，如 <code>module.rules</code> 里 <code>include/exclude</code>，配置 <code>resolve.modules/resolve.mainFields/resolve.extensions</code> ,配置 <code>noParse</code>，配置 <code>externals</code>， 配置 <code>IgnorePlugin</code> 等</li></ol><h2 id="后记" tabindex="-1">后记 <a class="header-anchor" href="#后记" aria-label="Permalink to &quot;后记&quot;">​</a></h2><p>从 <code>webpack</code> 源码开始，到后面打包结果分析、<code>watch</code>、<code>webpack</code> 优化总结等，前前后后花了一个月的时间，但收获也颇多。由于对 webpack 主流程的执行有了大概的认知，在遇到一些配置需要深入了解专研的时候，能快速定位在流程的哪个环节；在开发一个 loader 或者 plugin 也能有很清晰的思路；最重要的是通过对源码分析，大型工程的组织架构，扩展性，健壮性等给人带来一些新的思路和启发。</p><p>本系列到此结束，后续会不断的更新优化。对 <code>webpack</code> 的主流程分析解除了我心中很多的构建相关的疑惑，解开了心中的结。人生短短数十载，精力、时间都很有限，选择做让自己开发的事情，方为上策。</p><p><code>webpack5.0</code> 已到，后续有时间会分析与 <code>webpack 4.x</code> 不同的源码差异。</p><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p>',42),a=[l];function t(r,n,s,u,p,h){return c(),o("div",null,a)}const b=e(i,[["render",t]]);export{k as __pageData,b as default};
