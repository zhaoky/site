import{_ as s,c as i,o as a,U as e,bu as p}from"./chunks/framework.6i15RKC2.js";const y=JSON.parse('{"title":"深入理解“连等赋值”问题（转）","description":"","frontmatter":{},"headers":[],"relativePath":"misc/333.md","filePath":"misc/333.md"}'),l={name:"misc/333.md"},t=e(`<h1 id="深入理解-连等赋值-问题-转" tabindex="-1">深入理解“连等赋值”问题（转） <a class="header-anchor" href="#深入理解-连等赋值-问题-转" aria-label="Permalink to &quot;深入理解“连等赋值”问题（转）&quot;">​</a></h1><blockquote><p>原文链接：<code>https://segmentfault.com/a/1190000004224719</code></p></blockquote><p>有这样一个热门问题：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a.x); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// --&gt; undefined</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b.x); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// --&gt; {n: 2}</span></span></code></pre></div><p>其实这个问题很好理解，关键要弄清下面两个知识点：</p><ul><li><code>JS</code> 引擎对赋值表达式的处理过程</li><li>赋值运算的右结合性</li></ul><h3 id="一-赋值表达式" tabindex="-1">一. 赋值表达式 <a class="header-anchor" href="#一-赋值表达式" aria-label="Permalink to &quot;一. 赋值表达式&quot;">​</a></h3><p>形如</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>的表达式称为<strong>赋值表达式</strong>。其中 <code>A</code> 和 <code>B</code> 又分别可以是表达式。<code>B</code> 可以是任意表达式，但是 <code>A</code> 必须是一个<strong>左值</strong>。</p><p>所谓左值，就是可以被赋值的表达式，在 <code>ES</code> 规范中是用内部类型引用(<code>Reference</code>)描述的。例如：</p><ul><li>表达式 <code>foo.bar</code> 可以作为一个左值，表示对 <code>foo</code> 这个对象中 <code>bar</code> 这个名称的引用；</li><li>变量 <code>email</code> 可以作为一个左值，表示对当前执行环境中的环境记录项 <code>envRec</code> 中 <code>email</code> 这个名称的引用</li><li>同样地，函数名 <code>func</code> 可以做左值，然而函数调用表达式 <code>func(a, b)</code>不可以。</li></ul><p>那么 <code>JS</code> 引擎是怎样计算一般的赋值表达式 <code>A = B</code> 的呢？简单地说，按如下步骤：</p><ol><li>计算表达式 <code>A</code>，得到一个引用 <code>refA</code>；</li><li>计算表达式 <code>B</code>，得到一个值 <code>valueB</code>；</li><li>将 <code>valueB</code> 赋给 <code>refA</code> 指向的名称绑定；</li><li>返回 <code>valueB</code>。</li></ol><h3 id="二-结合性" tabindex="-1">二. 结合性 <a class="header-anchor" href="#二-结合性" aria-label="Permalink to &quot;二. 结合性&quot;">​</a></h3><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。 赋值表达式是右结合的。这意味着：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>等价于</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">A1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> A4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="三-连等的解析" tabindex="-1">三. 连等的解析 <a class="header-anchor" href="#三-连等的解析" aria-label="Permalink to &quot;三. 连等的解析&quot;">​</a></h3><p>好了，有了上面两部分的知识。下面来看一下 <code>JS</code> 引擎是怎样运算连等赋值表达式的。</p><p>以下面的式子为例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Exp1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exp2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exp3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exp4;</span></span></code></pre></div><p>首先根据右结合性，可以转换成</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Exp1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exp2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exp3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exp4;</span></span></code></pre></div><p>然后，我们已经知道对于单个赋值运算，<code>JS</code> 引擎总是先计算左边的操作数，再计算右边的操作数。所以接下来的步骤就是：</p><ol><li>计算 <code>Exp1</code>，得到 <code>Ref1</code>；</li><li>计算 <code>Exp2</code>，得到 <code>Ref2</code>；</li><li>计算 <code>Exp3</code>，得到 <code>Ref3</code>；</li><li>计算 <code>Exp4</code>，得到 <code>Value4</code>。</li></ol><p>现在变成了这样的：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Ref1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Ref2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Ref3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Value4;</span></span></code></pre></div><p>接下来的步骤是：</p><ol><li>将 <code>Value4</code> 赋给 <code>Exp3</code>；</li><li>将 <code>Value4</code> 赋给 <code>Exp2</code>；</li><li>将 <code>Value4</code> 赋给 <code>Exp1</code>；</li><li>返回表达式最终的结果 <code>Value4</code>。</li></ol><p>注意：这几个步骤体现了右结合性。</p><p>总结一下就是：</p><blockquote><p>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。</p></blockquote><h3 id="四-问题的解决" tabindex="-1">四. 问题的解决 <a class="header-anchor" href="#四-问题的解决" aria-label="Permalink to &quot;四. 问题的解决&quot;">​</a></h3><p>现在回到文章开头的问题。</p><p>首先前两个 <code>var</code> 语句执行完后，<code>a</code> 和 <code>b</code> 都指向同一个对象 {<code>n: 1}</code> (为方便描述，下面称为对象 <code>N1</code>)。然后来看</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span></code></pre></div><p>根据前面的知识，首先依次计算表达式 <code>a.x</code> 和 <code>a</code>，得到两个引用。其中 <code>a.x</code> 表示对象 <code>N1</code> 中的 <code>x</code>，而 <code>a</code> 相当于 <code>envRec.a</code>，即当前环境记录项中的 <code>a</code>。所以此时可以写出如下的形式：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">N1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]].x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [[encRec]].a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span></code></pre></div><p>其中，<code>[[]]</code> 表示引用指向的对象。</p><p>接下来，将 <code>{n: 2}</code> 赋值给 <code>[[encRec]].a</code>，即将 <code>{n: 2}</code> 绑定到当前上下文中的名称 <code>a</code>。</p><p>接下来，将同一个 <code>{n: 2}</code> 赋值给 <code>[[N1]].x</code>，即将 <code>{n: 2}</code> 绑定到 <code>N1</code> 中的名称 <code>x</code>。</p><p>由于 <code>b</code> 仍然指向 <code>N1</code>，所以此时有</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> N1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x: {n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}}</span></span></code></pre></div><p>而 <code>a</code> 被重新赋值了，所以</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>并且</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b.x;</span></span></code></pre></div><h3 id="五-最后的最后" tabindex="-1">五. 最后的最后 <a class="header-anchor" href="#五-最后的最后" aria-label="Permalink to &quot;五. 最后的最后&quot;">​</a></h3><p>如果你明白了上面所有的内容，应该会明白 <code>a.x = a = {n:2};</code> 与 <code>b.x = a = {n:2};</code> 是完全等价的。因为在解析 <code>a.x</code> 或 <code>b.x</code> 的那个时间点。<code>a</code> 和 <code>b</code> 这两个名称指向同一个对象，就像 <code>C++</code> 中同一个对象可以有多个引用一样。而在这个时间点之后，不论是 <code>a.x</code>还是 <code>b.x</code>，其实早就不存在了，它已经变成了 <code>那个内存中的对象.x</code> 了。</p><p>最后用一张图表示整个表达式的运算过程：</p><p><img src="`+p+'" alt="连等赋值"></p>',53),h=[t];function n(d,k,o,c,r,E){return a(),i("div",null,h)}const u=s(l,[["render",n]]);export{y as __pageData,u as default};
