import{_ as t,c as e,o as d,U as s}from"./chunks/framework.H2RWGpQP.js";const g=JSON.parse('{"title":"点击穿透（转）","description":"","frontmatter":{},"headers":[],"relativePath":"misc/360.md","filePath":"misc/360.md"}'),a={name:"misc/360.md"},i=s(`<h1 id="点击穿透-转" tabindex="-1">点击穿透（转） <a class="header-anchor" href="#点击穿透-转" aria-label="Permalink to &quot;点击穿透（转）&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>点击穿透这种现象算是移动 <code>web</code> 开发比较经典的问题，也常用来做面试题。本文目标是结合移动 <code>web</code> 开发的相关事件，介绍一下点击穿透现象形成的原因以及避免这种现象的解决方法。</p><h2 id="点击穿透现象" tabindex="-1">点击穿透现象 <a class="header-anchor" href="#点击穿透现象" aria-label="Permalink to &quot;点击穿透现象&quot;">​</a></h2><p>现象描述：</p><p>页面中存在上下两个层，上层元素具有表单，链接或者绑定相应事件，上层元素点击或触摸，导致上层 <code>DOM</code> 改变，下层中同样位置的元素触发点击事件。这种现象就是<code>点击穿透（Ghost Clicks）</code>。其实我觉得用“幽冥点击”称呼它更加带感。</p><p>要理解这种现象，首先要了解移动端的相关事件 —— <code>触摸(Touch)事件</code>，<code>点击(Click)事件</code>。</p><p><code>Touch</code> 事件中，常用的为 <code>touchstart</code>, <code>touchmove</code>, <code>touchend</code> 三种。除此之外还有 <code>touchcancel</code>。 注意，原生事件中并没有 <code>tap</code> 事件。下面会解释 <code>tap</code> 事件怎么产生的。</p><p>事件描述如下：</p><table><thead><tr><th>事件</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td>touchstart</td><td>开始触摸</td><td>手指接触屏幕时立即触发</td></tr><tr><td>touchmove</td><td>移动或拖拽</td><td>取决于系统和浏览器</td></tr><tr><td>touchend</td><td>触摸结束</td><td>手指离开屏幕时立即出发</td></tr></tbody></table><p>而 <code>Touch</code> 事件的触发一般通过手指，还会存在多点触控，拖拽方向等情况。列出几个重要参数如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>touches</td><td>屏幕中每根手指信息列表</td></tr><tr><td>targetTouches</td><td>和 touches 类似，把同一节点的手指信息过滤掉</td></tr><tr><td>changedTouches</td><td>响应当前事件的每根手指的信息列表</td></tr></tbody></table><p>代码获取如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">xxDOM.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;touchstart&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.touches, e.targetTouches, e.changedTouches);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>手指触发触摸事件的过程如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">touchstart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> touchmove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ...</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> touchmove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> touchend</span></span></code></pre></div><p>由此，我们可以在 <code>ontouchstart</code> 事件上记录开始触摸开始，<code>ontouchend</code> 记录触摸结束信息。</p><p>通过上述这些参数，很容易的去计算幽冥点击的时间，以及点击穿透的相关信息，包括响应的坐标情况。</p><h2 id="造成的原因" tabindex="-1">造成的原因 <a class="header-anchor" href="#造成的原因" aria-label="Permalink to &quot;造成的原因&quot;">​</a></h2><p>问题来了，<code>click 事件</code> 什么时候触发？</p><p>浏览器在 <code>touchend</code> 之后会等待约 <code>300ms</code> ，如果没有 <a href="https://www.cnblogs.com/zhuzhenwei918/p/7588553.html" target="_blank" rel="noreferrer">tap 行为</a>，则触发 <code>click</code> 事件。</p><p>而浏览器等待约 <code>300ms</code> 的原因是，判断用户是否是<code>双击（double tap）行为</code>，双击过程中就不适合触发 click 事件了。</p><p>由此可以看出 <code>click</code> 事件触发代表一轮触摸事件的结束。</p><p>上面说到原生事件中并没有 <code>tap</code> 事件，可以参考经典的 <code>zepto.js</code> 对 <code>singleTap</code> 事件的处理。<a href="https://github.com/madrobby/zepto/blob/master/src/touch.js#L136-L143" target="_blank" rel="noreferrer">见源码 136-143 行</a></p><p>可以看出，<code>singleTap</code> 事件的触发时机 —— 在 <code>touchend</code> 事件响应 <code>250ms</code> 无操作后，触发 <code>singleTap</code>。</p><p>因此，点击穿透的现象就容易理解了，在这 <code>300ms</code> 以内，因为上层元素隐藏或消失了，由于 <code>click</code> 事件的滞后性，同样位置的 <code>DOM</code> 元素触发了 <code>click</code> 事件（如果是 <code>input</code> 则触发了 <code>focus</code> 事件）。在代码中，给我们的感觉就是 <code>target</code> 发生了飘移。</p><h2 id="怎样避免点击穿透" tabindex="-1">怎样避免点击穿透 <a class="header-anchor" href="#怎样避免点击穿透" aria-label="Permalink to &quot;怎样避免点击穿透&quot;">​</a></h2><p>理解点击穿透的原因，我们从各种途径去阻止现象的产生。</p><p>毫无疑问，能想到的方法很多，比如中间的层添加一个 <code>300ms</code> 渐隐的动画，触摸结束后阻止 <code>click</code> 事件等。</p><ol><li><p>触摸开始时 <code>touchstart</code> 事件触发时，<code>preventDefault()</code>。毫无疑问，很容易想到这一点，而且也从根本上解决了这个问题。但是，它有一个避免不了或者说引入了很大的缺陷，页面中 <code>DOM</code> 元素无法再进行滚动了。这个方法显然不能满足我们的需求，但是这个思路其实可以给我们更多的启发，比如说 <code>iscroll</code> 只允许横向滚动的实现，相关实现这里暂且不表。</p></li><li><p>触摸结束时 <code>touchend</code> 事件触发时，<code>preventDefault()</code>。看上去好像没有什么问题，但是，很遗憾的是不是所有的浏览器都支持。</p></li><li><p>禁止页面缩放 通过设置 <code>meta</code> 标签，可以禁止页面缩放，部分浏览器不再需要等待 <code>300ms</code>，导致点击穿透。点击事件仍然会触发，但相对较快，所以 <code>click</code> 事件从某种意义上来说可以取代点击事件， 而代价是牺牲少数用户（<code>click</code> 事件触发仍然较慢）的体验。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, user-scalable=no&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p><code>IE 10</code> 可以用 <code>CSS</code> 取消点击穿透的延迟：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  -ms-touch-action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">manipulation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  touch-action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">manipulation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>IE 11+</code> 可以用 <code>touch-action: manipulation;</code> 属性来阻止元素的双击缩放。</p></li><li><p>CSS3 的方法 虽然主要讲的是事件，但是有必要介绍一个 CSS3 的属性 —— <code>pointer-events</code>。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">pointer-events</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit;</span></span></code></pre></div><p><code>pointer-events</code> 属性有很多值，有用的主要是 <code>auto</code> 和 <code>none</code>，其他属性为 <code>SVG</code> 服务。</p><p><a href="https://caniuse.com/#search=pointer-events" target="_blank" rel="noreferrer">查看浏览器支持情况</a> 可见移动端开发还是可以用的。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>auto</td><td>默认值，鼠标或触屏事件不会穿透当前层</td></tr><tr><td>none</td><td>元素不再是 target，监听的元素变成了下层的元素（如果子元素设置成 auto，点击子元素会继续监听事件）</td></tr></tbody></table></li><li><p>处理点击事件 —— <code>Touch to Click</code> 最靠谱的方案还是从点击事件的根源上解决问题。用 <code>js</code> 去判断幽冥点击，然后阻止点击穿透。这种方式显然可以实现，缺点是阻止点击穿透时需要小心，不要导致原生的 <code>HTML</code> 元素（如：链接，多选框，单选框）无法正常运行。</p><p>通过上文中介绍的 <code>touches，targetTouches，changedTouches</code> 参数，我们可以构建出这样的测试页面，可以统计出点击穿透的时间，以及已经响应的情况。</p><table><thead><tr><th></th><th>preventDefault()</th><th>preventDefault()</th><th>点击穿透时间</th><th>点击穿透时间</th><th>点击穿透区域</th><th>点击穿透区域</th></tr></thead><tbody><tr><td>Browser</td><td>touchstart</td><td>touchend</td><td>缩放页面</td><td>禁止缩放页面</td><td>缩放页面</td><td>禁止缩放页面</td></tr><tr><td>Safari Mobile iOS 5.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 6.1.3</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 7.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 2.3.7</td><td>Yes</td><td>No</td><td>410ms after end</td><td>410ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.0.4</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.1.2</td><td>Yes</td><td>No</td><td>300ms after end</td><td>300ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.2.2</td><td>Yes</td><td>No</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>IE10 Windows Phone 8</td><td>No</td><td>No</td><td>310ms after end</td><td>10ms after end</td><td>touchend</td><td>touchend</td></tr><tr><td>Blackberry 10</td><td>Yes</td><td>Yes</td><td>260ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for iOS</td><td>Yes</td><td>Yes</td><td>360ms after end</td><td>360ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for Android</td><td>Yes</td><td>Yes</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>Firefox for Android</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr></tbody></table><p>由此可以看出：</p><ul><li>点击穿透受浏览器和页面是否缩放影响</li><li>点击穿透有两种情况：快速情况有 <code>10ms</code> 慢速情况有 <code>300ms</code></li><li>在 <code>touchend</code> 时间上调用 <code>preventDefault()</code> 可以阻止多数情况的点击穿透</li></ul><p>代码上处理建议如下：</p><ul><li>在 <code>touchend</code> 事件上调用 <code>preventDefault()</code></li><li>在一次成功的点击后，建议接下来的 <code>500ms</code> 以内取消所有的 <code>click</code> 事件。</li><li>分析点击事件，判断如果是慢速点击穿透，则取消所有 <code>click</code> 事件，如果是快速点击穿透，取消触摸事件 <code>50ms</code> 以内的 <code>click</code> 事件即可。</li></ul><p>有个好消息是，移动端开发已经有人写好相应的库，帮助我们处理点击穿透。</p><p><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noreferrer">fastclick</a> 可以参考和使用。</p><p>其实现思路是，取消 <code>click</code> 事件<a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js#L521-L610" target="_blank" rel="noreferrer">（参看源码 164-173 行）</a>，用 <code>touchend</code> 模拟快速点击行为<a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js#L164-L173" target="_blank" rel="noreferrer">（参看源码 521-610 行）</a>。</p></li></ol><h2 id="原文链接" tabindex="-1">原文链接 <a class="header-anchor" href="#原文链接" aria-label="Permalink to &quot;原文链接&quot;">​</a></h2><p><a href="http://liudong.me/conclusion/touch-defect/" target="_blank" rel="noreferrer">点击穿透</a></p>`,32),o=[i];function c(h,n,r,l,p,k){return d(),e("div",null,o)}const E=t(a,[["render",c]]);export{g as __pageData,E as default};
