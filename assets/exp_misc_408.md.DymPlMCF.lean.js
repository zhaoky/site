import{_ as a,c as s,o as e,R as l}from"./chunks/framework.Dxoqk0BT.js";const c=JSON.parse('{"title":"《Javascript 密码花园》 笔记","description":"","frontmatter":{},"headers":[],"relativePath":"exp/misc/408.md","filePath":"exp/misc/408.md"}'),t={name:"exp/misc/408.md"};function n(h,i,p,r,d,o){return e(),s("div",null,[...i[0]||(i[0]=[l(`<h1 id="《javascript-密码花园》-笔记" tabindex="-1">《Javascript 密码花园》 笔记 <a class="header-anchor" href="#《javascript-密码花园》-笔记" aria-label="Permalink to &quot;《Javascript 密码花园》 笔记&quot;">​</a></h1><blockquote><p><a href="https://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noreferrer">《Javascript 密码花园》</a></p></blockquote><p>本笔记只记录本人易模糊的知识点，其他略过。</p><h2 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h2><ul><li><p><code>JavaScript</code> 中所有变量都可以当作对象使用，除了两个例外 <code>null</code> 和 <code>undefined</code>。</p></li><li><p>由于 <code>JavaScript</code> 解析器的一个错误，数字的字面值（literal）当作对象解析时报错：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 出错：SyntaxError</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 变通写法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二个点号可以正常解析</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注意点号前面的空格</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2先被计算</span></span></code></pre></div></li><li><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。中括号还适合动态属性等。</p></li><li><p>删除属性的唯一方法是使用 <code>delete</code> 操作符。</p></li><li><p>不要扩展内置类型的原型，除非是为了和新的 <code>JavaScript</code> 引擎兼容。</p></li></ul><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><ul><li><p>命名函数的赋值表达式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正常运行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 出错：ReferenceError</span></span></code></pre></div></li><li><p>不要使用 <code>arguments.callee</code> 和它的属性。</p></li><li><p>推荐使用匿名包装器（自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突，而且有利于程序的模块化。</p></li></ul><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h2><ul><li>为了更好的性能，推荐使用普通的 <code>for</code> 循环并缓存数组的 <code>length</code> 属性。</li></ul><h2 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-label="Permalink to &quot;类型&quot;">​</a></h2><ul><li>强烈推荐使用严格等于操作符。如果类型需要转换，应该在比较之前显式的转换， 而不是使用语言本身复杂的强制转换规则。</li><li>为了检测一个对象的类型，强烈推荐使用 <code>Object.prototype.toString</code> 方法； 因为这是唯一一个可依赖的方式。</li><li><code>instanceof</code> 操作符应该仅仅用来比较来自同一个 <code>JavaScript</code> 上下文的自定义对象。</li></ul><h2 id="核心" tabindex="-1">核心 <a class="header-anchor" href="#核心" aria-label="Permalink to &quot;核心&quot;">​</a></h2><ul><li>绝对不要使用 <code>eval</code>，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 99.9% 使用 <code>eval</code> 的场景都有不使用 <code>eval</code> 的解决方案。</li></ul><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><ul><li>绝对不要使用字符串作为 <code>setTimeout</code> 或者 <code>setInterval</code> 的第一个参数。</li><li>避免使用 <code>setInterval</code>，可以在回调函数内部使用 <code>setTimeout</code>。</li></ul>`,15)])])}const g=a(t,[["render",n]]);export{c as __pageData,g as default};
