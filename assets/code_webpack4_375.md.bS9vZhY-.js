import{_ as s,c as i,o as a,U as e}from"./chunks/framework.UMIDyG6S.js";const y=JSON.parse('{"title":"源码分析（四）：reslove 前的准备","description":"","frontmatter":{},"headers":[],"relativePath":"code/webpack4/375.md","filePath":"code/webpack4/375.md"}'),o={name:"code/webpack4/375.md"},l=e(`<h1 id="源码分析-四-reslove-前的准备" tabindex="-1">源码分析（四）：reslove 前的准备 <a class="header-anchor" href="#源码分析-四-reslove-前的准备" aria-label="Permalink to &quot;源码分析（四）：reslove 前的准备&quot;">​</a></h1><h2 id="compiler-run" tabindex="-1">compiler.run <a class="header-anchor" href="#compiler-run" aria-label="Permalink to &quot;compiler.run&quot;">​</a></h2><p><code>compiler.run</code>是整个编译过程启动的入口，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hooks.beforeRun.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hooks.run.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // recordsInputPath是webpack配置中指定的读取上一组records的文件路径</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readRecords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(onCompiled);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>在方法中先触发 <code>compiler.hooks</code>: <code>beforeRun</code>，执行之前注册的 <code>NodeEnvironmentPlugin</code>（该插件此时判断 <code>inputFileSystem</code> 是否被配置，如未配置则执行 <code>purge</code> 清理方法），然后在回调里触发 <code>compiler.hooks</code>: <code>run</code>，然后回调里 <code>this.readRecords</code> 是用于读取之前的 <code>records</code> 的方法，再在它的回调里执行 <code>this.compile(onCompiled)</code>。</p><p><code>onCompiled</code> 在 <code>compile</code> 过程后调用，主要用于输出构建资源。</p><h2 id="compiler-compile" tabindex="-1">compiler.compile <a class="header-anchor" href="#compiler-compile" aria-label="Permalink to &quot;compiler.compile&quot;">​</a></h2><p><code>compile</code> 是真正进行编译的过程，最终会把所有原始资源编译为目标资源。实例化了一个 <code>compilation</code>，并将 <code>compilation</code> 传给 <code>make</code> 钩子上的方法，注册在这些钩子上的方法会调用 <code>compilation</code> 上的 <code>addEntry</code>，执行构建。</p><h3 id="获取-compilation-所需-params" tabindex="-1">获取 compilation 所需 params <a class="header-anchor" href="#获取-compilation-所需-params" aria-label="Permalink to &quot;获取 compilation 所需 params&quot;">​</a></h3><p><code>this.compile</code> 先执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newCompilationParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>即：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newCompilationParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        normalModuleFactory: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createNormalModuleFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        contextModuleFactory: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createContextModuleFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        compilationDependencies: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> params;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>该方法先实例化了 <code>NormalModuleFactory</code> 类和 <code>ContextModuleFactory</code> 类，两个类均扩展于 <code>tapable</code>。<code>ContextModuleFactory</code> 类除了兼容老版本之外的代码，没有什么特别需要注意的。接下来具体说明 <code>NormalModuleFactory</code>。</p><h3 id="实例化-normalmodulefactory" tabindex="-1">实例化 NormalModuleFactory <a class="header-anchor" href="#实例化-normalmodulefactory" aria-label="Permalink to &quot;实例化 NormalModuleFactory&quot;">​</a></h3><p><code>NormalModuleFactory</code> 类用于创建一个 <code>normalModule</code> 实例。</p><h4 id="实例化-ruleset" tabindex="-1">实例化 RuleSet <a class="header-anchor" href="#实例化-ruleset" aria-label="Permalink to &quot;实例化 RuleSet&quot;">​</a></h4><p>在实例化 <code>NormalModuleFactory</code> 执行 <code>constructor</code> 的过程中，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ruleSet </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RuleSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options.defaultRules.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">concat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(options.rules));</span></span></code></pre></div><ul><li><code>options.defaultRules</code> 是在之前文件 <code>WebpackOptionsDefaulter.js</code> 中被初始化，然后与项目配置的 <code>module.rules</code> 合并；</li><li>每个<a href="https://webpack.docschina.org/configuration/module/#rule" target="_blank" rel="noreferrer">规则</a>可以分为三部分 - 条件 <code>condition</code> (如 <code>test, include, exclude</code>)，结果 <code>result</code> (如应用的 <code>loader，parse</code> 选项) 和嵌套规则 <code>nested rule</code>（如 <code>rules</code>）；</li><li><a href="https://webpack.docschina.org/configuration/module/#%E6%9D%A1%E4%BB%B6" target="_blank" rel="noreferrer">条件</a>可接受 正则表达式，字符串，函数等。</li><li><code>new RuleSet</code> 实例化过程中，会对每一项 <code>rule</code> 进行进行处理，递归调用静态方法 <code>normalizeCondition</code> 处理 <code>condition</code> 相关，最终每一个 <code>condition</code> 都处理为一个 <code>newRule.resource</code> 函数；递归调用 <code>normalizeUse</code> 处理 <code>result</code> 相关，最终每一个 <code>result</code> 都处理为一个 <code>use</code> 数组，数组的每一项包含 <code>loader</code> 和 <code>options</code>；</li><li>调用 <code>ruleSet</code> 的实例 <code>exec</code> 时，传入目标路径和相关信息后，在内部 <code>_run</code> 里，进行递归过滤匹配出对应的 <code>loader</code>，最终得到 <code>result</code> 数组，数组每一项包含 <code>type，value（loader 和 options）</code> 等；</li></ul><h4 id="注册-normalmodulefactory-hooks-factory" tabindex="-1">注册 <code>normalModuleFactory.hooks</code>:<code>factory</code> <a class="header-anchor" href="#注册-normalmodulefactory-hooks-factory" aria-label="Permalink to &quot;注册 \`normalModuleFactory.hooks\`:\`factory\`&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hooks.factory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;NormalModuleFactory&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resolver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hooks.resolver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  resolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>此时注册了 <code>normalModuleFactory.hooks</code>:<code>factory</code>，当后面触发该 <code>hooks</code> 时，该回调返回一个函数。函数内的运行须先触发 <code>normalModuleFactory.hooks</code>:<code>resolver</code>，然后执行其回调结果。</p><h4 id="注册-normalmodulefactory-hooks-resolver" tabindex="-1">注册 <code>normalModuleFactory.hooks</code>:<code>resolver</code> <a class="header-anchor" href="#注册-normalmodulefactory-hooks-resolver" aria-label="Permalink to &quot;注册 \`normalModuleFactory.hooks\`:\`resolver\`&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hooks.resolver.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;NormalModuleFactory&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>此时注册了 <code>normalModuleFactory.hooks</code>:<code>resolver</code>，跟<code>normalModuleFactory.hooks</code>:<code>factory</code> 相同，当后面触发该 <code>hooks</code> 时，该回调返回一个函数。</p><p>在这两个类实例化完成后，分别触发 <code>compiler.hooks</code>: <code>normalModuleFactory</code> ，<code>contextModuleFactory</code>。</p><h3 id="实例化-compilation" tabindex="-1">实例化 compilation <a class="header-anchor" href="#实例化-compilation" aria-label="Permalink to &quot;实例化 compilation&quot;">​</a></h3><p><code>this.compile</code> 继续执行,先后触发 <code>compiler.hooks</code>: <code>beforeCompile</code>，<code>compile</code>, 这两个钩子都会传入上文 <code>params</code> 作为参数，可用于修改 <code>normalModuleFactory，contextModuleFactory</code> 等。然后在回调中执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> compilation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newCompilation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(params);</span></span></code></pre></div><p>该方法实例化了一个 <code>Compilation</code>，也是扩展于 <code>tapable</code>。<strong>一个 <code>compilation</code> 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，代表了一次资源的构建</strong>。</p><p>在实例化的过程中，除了初始化一些自身资源属性，并实例化了 <code>MainTemplate</code>, <code>ChunkTemplate</code>, <code>HotUpdateChunkTemplate</code>, <code>RuntimeTemplate</code>, <code>ModuleTemplate</code>。用于提供不同的编译模板。</p><p>回到 <code>compiler.js</code>，在添加了一些属性后，触发<code>compiler.hooks</code> : <code>thisCompilation</code>, <code>compilation</code>。回忆在 <code>编译前的准备 - 注册plugins阶段 - WebpackOptionsApply.js</code> 的文件里注册了大量该 <code>hooks</code> 的事件，在此时拿到 <code>compilation</code> 对象后，开始执行这一系列事件。</p><ul><li><code>compiler.hooks</code>:<code>thisCompilation</code> 会在 <code>compilation</code> 对象的 <code>hooks</code> 里注册一些新的事件；</li><li><code>compiler.hooks</code>:<code>compilation</code> 会在 <code>compilation</code>、<code>normalModuleFactory</code> 对象的 <code>hooks</code> 里注册一些新的事件，同时还会往 <code>compilation.dependencyFactories</code>（工厂类），<code>compilation.dependencyTemplates</code>（模板类） 增加依赖模块。</li></ul><blockquote><p>为什么这里需要 <code>thisCompilation，compilation</code> 两个钩子？原因是跟子编译器有关。在 <code>Compiler</code> 的 <code>createChildCompiler</code> 方法里创建子编译器，其中 <code>thisCompilation</code> 钩子不会被复制，而 <code>compilation</code> 会被复制。 子编译器拥有完整的 <code>module</code> 和 <code>chunk</code> 生成，通过子编译器可以独立于父编译器执行一个核心构建流程，额外生成一些需要的 <code>module</code> 和 <code>chunk</code>。</p></blockquote><h2 id="开始构建" tabindex="-1">开始构建 <a class="header-anchor" href="#开始构建" aria-label="Permalink to &quot;开始构建&quot;">​</a></h2><p><code>this.compile</code> 继续执行，触发 <code>compiler.hooks</code> : <code>make</code> ,执行之前在 <code>SingleEntryPlugin | MultiEntryPlugin</code> 注册的的 <code>make</code> 事件，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">compilation.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, dep, name, callback); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//其中 dep 为 SingleEntryDependency 实例</span></span></code></pre></div><h3 id="compilation-addentry" tabindex="-1">compilation.addEntry <a class="header-anchor" href="#compilation-addentry" aria-label="Permalink to &quot;compilation.addEntry&quot;">​</a></h3><p>来到 <code>Compilation.js</code> 文件，<code>addEntry</code> 触发了 <code>compilation.hooks</code>:<code>addEntry</code> 后，定义了入口对象 <code>_preparedEntrypoints</code>，然后直接执行了 <code>this._addModuleChain</code>。</p><p>在该方法里，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {DepConstructor}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dependency.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moduleFactory</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dependencyFactories.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Dep);</span></span></code></pre></div><p>因 <code>dependency = SingleEntryPlugin.createDependency(entry, name)</code> 即 <code>new SingleEntryDependency(entry)</code>，则 <code>Dep</code> 则为 <code>SingleEntryDependency</code> 类，而在之前 <code>compiler.hooks:compilation</code> 的注册事件中添加了依赖： <code>compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory)</code>，所以 <code>moduleFactory</code> 为 <code>normalModuleFactory</code>。</p><h3 id="开始创建-module" tabindex="-1">开始创建 module <a class="header-anchor" href="#开始创建-module" aria-label="Permalink to &quot;开始创建 module&quot;">​</a></h3><h4 id="编译队列控制-semaphore-acquire" tabindex="-1">编译队列控制：semaphore.acquire <a class="header-anchor" href="#编译队列控制-semaphore-acquire" aria-label="Permalink to &quot;编译队列控制：semaphore.acquire&quot;">​</a></h4><p>执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.semaphore.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">acquire</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  moduleFactory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><code>this.semaphore</code> 这个类是一个编译队列控制，原理很简单，对执行进行了并发控制，默认并发数为 <code>100</code>，超过后存入 <code>semaphore.waiters</code>，根据情况再调用 <code>semaphore.release</code> 去执行存入的事件 <code>semaphore.waiters</code>。</p><h4 id="modulefactory-create" tabindex="-1">moduleFactory.create <a class="header-anchor" href="#modulefactory-create" aria-label="Permalink to &quot;moduleFactory.create&quot;">​</a></h4><p><code>this.semaphore.acquire</code> 里执行了 <code>moduleFactory.create</code>。（<strong>注：递归解析依赖的重复也从此处开始</strong>）</p><h2 id="本章小结" tabindex="-1">本章小结 <a class="header-anchor" href="#本章小结" aria-label="Permalink to &quot;本章小结&quot;">​</a></h2><ol><li>从编译过程启动的入口 <code>compiler.run</code> 开始，触发了一系列的生命周期钩子后，执行 <code>compiler.compile</code>。</li><li>获取 <code>compilation</code> 所需 <code>params</code>，实例化 <code>NormalModuleFactory</code> 类（插件会去注册其钩子） 及 <code>ContextModuleFactory</code> 类，在实例化 <code>NormalModuleFactory</code> 的过程中，会实例化 <code>RuleSet</code> 及注册钩子 <code>factory</code> 和 <code>resolver</code>。</li><li>实例化 <code>Compilation</code>，传入 <code>params</code> 参数，触发之前在注册 <code>plugin</code> 阶段所注册的 <code>NormalModuleFactory</code> 下的 <code>hooks</code>。</li><li>触发 <code>make</code> 钩子执行 <code>compilation.addEntry-&gt;_addModuleChain</code>，通过编译队列控制 <code>semaphore.acquire</code> 执行 <code>moduleFactory.create</code> 开始创建 <code>module</code>，而递归解析依赖的重复点亦从 <code>create</code> 开始。</li></ol>`,52),n=[l];function t(h,d,p,c,k,r){return a(),i("div",null,n)}const g=s(o,[["render",t]]);export{y as __pageData,g as default};
