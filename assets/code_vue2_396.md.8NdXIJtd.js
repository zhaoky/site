import{_ as s,c as i,o as e,U as a}from"./chunks/framework.Pf98aJyB.js";const g=JSON.parse('{"title":"源码笔记（五）：beforeMount 阶段","description":"","frontmatter":{},"headers":[],"relativePath":"code/vue2/396.md","filePath":"code/vue2/396.md"}'),n={name:"code/vue2/396.md"},t=a(`<h1 id="源码笔记-五-beforemount-阶段" tabindex="-1">源码笔记（五）：beforeMount 阶段 <a class="header-anchor" href="#源码笔记-五-beforemount-阶段" aria-label="Permalink to &quot;源码笔记（五）：beforeMount 阶段&quot;">​</a></h1><p>接上文，在触发生命周期钩子 <code>created</code> 后，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (vm.$options.el) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  vm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$mount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.$options.el);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>该句执行完后，<code>_init</code> 方法（位置在 <code>src/core/instance/init.js</code>）执行结束。</p><h2 id="mount-简述" tabindex="-1"><code>$mount</code> 简述 <a class="header-anchor" href="#mount-简述" aria-label="Permalink to &quot;\`$mount\` 简述&quot;">​</a></h2><p>判断是否有 <code>$options.el</code>，如果有就直接执行：<code>vm.$mount(vm.$options.el)</code>。在前面已经提到 <code>$mount</code> 方法与平台相关，所以在本例会执行 <code>entry-runtime-with-compiler.js</code> 中的 <code>$mount</code>。</p><p><code>$mount</code> 的主要功能是根据 <code>el</code> 或者 <code>options</code> 里的 <code>template</code>，通过编译器编译成 <code>render</code> 和 <code>staticRenderFns</code>。</p><h2 id="构建-render" tabindex="-1">构建 <code>render</code> <a class="header-anchor" href="#构建-render" aria-label="Permalink to &quot;构建 \`render\`&quot;">​</a></h2><p><code>$mount</code> 里先取得 <code>el</code> 对应的 <code>dom</code> 节点，然后判断 <code>options</code>(即 <code>this.$options</code>) 里有没有 <code>render</code> 方法，有 <code>render</code> 就可以直接跳过取 <code>template</code> 的过程了；没有 <code>render</code> 则判断 <code>options</code> 有没有 <code>template</code>，没有提供 <code>template</code> 就用 <code>getOuterHTML(el)</code> 得一个 <code>template</code>。</p><h3 id="compiletofunctions" tabindex="-1">compileToFunctions <a class="header-anchor" href="#compiletofunctions" aria-label="Permalink to &quot;compileToFunctions&quot;">​</a></h3><p>得到 <code>template</code> 后，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ref </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compileToFunctions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  template,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outputSourceRange: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NODE_ENV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;production&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shouldDecodeNewlines: shouldDecodeNewlines,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    delimiters: options.delimiters,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    comments: options.comments,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><code>compileToFunctions</code> 是柯里化函数 <code>createCompileToFunctionFn(compile)</code> 的返回值，主要作用是将 <code>template</code> 转化为 <code>render</code> 函数。</p><p>内部先执行 <code>new Function(&#39;return 1&#39;)</code> 来判断 <code>csp</code> 的配置，然后根据(<code>options.delimiters</code>)是否存在设置 <code>key</code>， 判断缓存后执行：</p><h4 id="compile" tabindex="-1">compile <a class="header-anchor" href="#compile" aria-label="Permalink to &quot;compile&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> compiled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(template, options);</span></span></code></pre></div><p><code>compile</code> 在 <code>createCompiler</code> 里定义，方法里先处理合并处理了 <code>compileToFunctions</code> 传入的 <code>options</code> 和 <code>baseOptions</code>(来自平台相关) 相关配置（定义了 <code>warn</code>，合并了 <code>modules</code>，<code>directives</code>）得到 <code>finalOptions</code>，然后执行：</p><h5 id="basecompile" tabindex="-1">baseCompile <a class="header-anchor" href="#basecompile" aria-label="Permalink to &quot;baseCompile&quot;">​</a></h5><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> compiled </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> baseCompile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(template.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trim</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), finalOptions);</span></span></code></pre></div><p><code>baseCompile</code> 方法里执行 3 个步骤：</p><ul><li><p><code>parse</code> 模板解析为 <code>ast</code></p></li><li><p><code>optimize</code> 标记静态节点,分别递归调用 <code>markStatic$1</code> 和 <code>markStaticRoots</code> 方法得到静态节点标志挂载在 <code>ast</code> 对象下的的 <code>static</code> 和 <code>staticRoot</code> 属性。其中 <code>static</code>代表该节点是普通静态节点，<code>staticRoot</code> 代表是可以优化的静态节点，他来自于：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node.static </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node.children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.children[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  node.staticRoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  node.staticRoot </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>表明如果 <code>node.static</code> 为真(即静态节点)且他不仅仅只有一个文本子元素为的时候 <code>node.staticRoot</code> 就为真，即用来优化。如果只有一个子文本元素就无需优化，优化反而增加成本。</p></li><li><p><code>generate</code> 将 <code>AST</code> 转换成渲染函数，其中如果有标记 <code>node.staticRoot</code> 为真，则将 <code>staticRenderFns</code> 数组增加一个静态的 <code>render</code>。</p></li></ul><p>最终 <code>baseCompile</code> 返回：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ast: ast,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  render: code.render,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  staticRenderFns: code.staticRenderFns,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>继而 <code>compile</code> 返回：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ast: {type: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, attrsList: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), attrsMap: {…}, rawAttrsMap: {…}, …}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  render: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;with(this){return _c(&#39;div&#39;,{attrs:{&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">main</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;}...&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  staticRenderFns: []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  errors: []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tips: []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>处理编译错误后，对 <code>render</code> 和 <code>staticRenderFns</code> 进行函数包装( <code>createFunction</code> )并缓存结果，这样在后续如果再次解析到相同的模板可以直接读缓存。</p><p>继而 <code>compileToFunctions</code> 返回：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  staticRenderFns: [],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>到此 <code>template-&gt;render</code> 的编译过程结束。</p><h2 id="执行-runtime-里的原-mount-及-mountcomponent" tabindex="-1">执行 runtime 里的原 <code>$mount</code> 及 mountComponent <a class="header-anchor" href="#执行-runtime-里的原-mount-及-mountcomponent" aria-label="Permalink to &quot;执行 runtime 里的原 \`$mount\` 及 mountComponent&quot;">​</a></h2><p>回到 <code>vm.$mount</code> 方法里继续执行，将 <code>render</code> 和 <code>staticRenderFns</code> 赋到 <code>vm.$options</code> 上后，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mount.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el, hydrating);</span></span></code></pre></div><p>即执行被覆盖的之前的 <code>$mount</code> (<code>/runtime/index</code> 中定义)，内部执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mountComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, el, hydrating);</span></span></code></pre></div><p>在 <code>mountComponent</code> (<code>core/instance/lifecycle</code> 中定义)里先将原始的真实 <code>el</code> 赋给 <code>vm.$el</code>，判断 <code>$options.render</code> 是否存在进行相关报错处理。</p><h2 id="触发-beforemount-钩子" tabindex="-1">触发 beforeMount 钩子 <a class="header-anchor" href="#触发-beforemount-钩子" aria-label="Permalink to &quot;触发 beforeMount 钩子&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callHook</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;beforeMount&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>执行生命周期钩子 <code>beforeMount</code>，打印 <code>vue beforeMount</code>。</p><h2 id="本章小结" tabindex="-1">本章小结 <a class="header-anchor" href="#本章小结" aria-label="Permalink to &quot;本章小结&quot;">​</a></h2><ol><li>本章介绍了 <code>vue</code> 执行的 <code>beforeMount</code> 阶段；</li><li>该阶段主要执行与平台相关的 <code>$mount</code>，主要生成 <code>render</code> 函数；</li><li><code>$mount</code>经过 <code>compileToFunctions -&gt; compile -&gt; baseCompile</code> 得到 <code>render</code>，其中 <code>baseCompile</code> 的执行会经过 3 个阶段；</li><li>在 <code>$mount</code> 最后执行原 <code>$mount</code>（平台相关），方法里执行 <code>mountComponent</code> 开始进入构建 <code>vnode</code> 阶段。</li></ol>`,40),p=[t];function l(o,h,d,c,k,r){return e(),i("div",null,p)}const u=s(n,[["render",l]]);export{g as __pageData,u as default};
