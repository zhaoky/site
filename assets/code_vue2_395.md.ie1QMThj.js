import{_ as s,c as a,o as i,U as e}from"./chunks/framework.GU250d-J.js";const g=JSON.parse('{"title":"源码笔记（四）：created 阶段","description":"","frontmatter":{},"headers":[],"relativePath":"code/vue2/395.md","filePath":"code/vue2/395.md"}'),t={name:"code/vue2/395.md"},n=e(`<h1 id="源码笔记-四-created-阶段" tabindex="-1">源码笔记（四）：created 阶段 <a class="header-anchor" href="#源码笔记-四-created-阶段" aria-label="Permalink to &quot;源码笔记（四）：created 阶段&quot;">​</a></h1><p>接上文继续分析，在触发生命周期钩子 <code>beforeCreate</code> 后，执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initInjections</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// resolve injections before data/props</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">initProvide</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// resolve provide after data/props</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callHook</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;created&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="initinjections" tabindex="-1">initInjections <a class="header-anchor" href="#initinjections" aria-label="Permalink to &quot;initInjections&quot;">​</a></h2><p>依赖注入，用于层级组件间传值，不可响应。</p><p>判断是否存在 <code>$options.inject</code>，然后在 <code>resolveInject</code> 里递归向上各级父元素中查找 <code>vm._provided</code> 属性值里是否有对应的注入值。找到最新值后放在实例下监听， <code>set</code> 方法设置无法重写，即不能更改注入值。</p><h2 id="initstate" tabindex="-1">initState <a class="header-anchor" href="#initstate" aria-label="Permalink to &quot;initState&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> initState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  vm._watchers </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vm.$options;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (opts.props) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    initProps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, opts.props);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (opts.methods) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    initMethods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, opts.methods);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (opts.data) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    initData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      (vm._data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}),</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* asRootData */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (opts.computed) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    initComputed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, opts.computed);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (opts.watch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opts.watch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nativeWatch) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    initWatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, opts.watch);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>依次对用户提供的 <code>options</code> 的字段进行初始化处理，会判断字段名是否合法等。顺序是：<code>props，methods，data，computed，watch</code>。</p><h3 id="props" tabindex="-1">props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;props&quot;">​</a></h3><p>如果是子组件的 <code>props</code>，则对每一项 <code>propsOptions</code> 执行 <code>loop</code>，方法里将 <code>propsOptions</code> 的 <code>key</code> 存入 <code>vm.$options._propKeys</code>，验证 <code>props</code> 类型，然后将每一项 <code>props</code> 存入 <code>vm._props</code> 里并监听，<code>set</code> 方法设置无法重写，即不能更改注入值。</p><h3 id="methods" tabindex="-1">methods <a class="header-anchor" href="#methods" aria-label="Permalink to &quot;methods&quot;">​</a></h3><p>其中初始化 <code>methods</code> 会把方法验证后，依次附到 <code>Vue</code> 实例 <code>vm</code> 下。</p><h3 id="data" tabindex="-1">data <a class="header-anchor" href="#data" aria-label="Permalink to &quot;data&quot;">​</a></h3><p>如果不是组件，其中初始化 <code>data</code> 会执行 <code>getData() =&gt; data() =&gt; mergedInstanceDataFn()</code>，即在 <code>mergeOptions</code> 方法里 <code>strats</code> 处理 <code>data</code> 的时候返回的 <code>mergedInstanceDataFn</code>。在其中 <code>mergeData</code> 了父 <code>data</code> 和自己的 <code>data</code>，然后返回。</p><p>如果是组件，则在执行 <code>data()</code> 即执行传入的 <code>options</code> 里的 <code>data</code> 函数，然后返回 <code>data</code> 对象值并赋给 <code>_data</code>。所以须保证 <code>data</code> 为函数返回一个新的对象，否则如果在模板中多次声明同一组件，组件中的 <code>data</code> 会指向同一个引用。</p><p>然后对 <code>data</code> 中每一项进行了合法性判断，然后执行 <code>proxy(vm, &quot;_data&quot;, key)</code> ，将 <code>key</code> 挂载在 <code>vm</code> 实例上，监听 <code>data</code> 第一层的所有属性。保证在读取或者设置 <code>vm.someData</code> 时会触发监听执行 <code>return vm[&#39;_data&#39;][&#39;somedata&#39;]</code> 或 <code>vm[&#39;_data&#39;][&#39;somedata&#39;] = val</code>，进而触发下文 <code>data</code> 上对每一个属性的监听。</p><p>循环执行完后，然后执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* asRootData */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//即 _data</span></span></code></pre></div><p>方法里先判断 <code>data</code> 里 <code>__ob__</code> 是否存在，如果不存在则执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Observer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Observer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.vmCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  def</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;__ob__&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (hasProto) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      protoAugment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, arrayMethods);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      copyAugment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value, arrayMethods, arrayKeys);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observeArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//递归遍历监听数组的每一项</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">walk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//递归遍历监听对象的每一个属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><strong>该方法里对每一个属性及其子属性递归初始化订阅者列表，当读取到某一属性时，就会把当前 watcher 加入到该属性的订阅列表里，当设置某一属性时，就会去通知订阅列表里所有的 watcher 执行其对应的 update 方法。</strong></p><h4 id="ob" tabindex="-1"><code>__ob__</code> <a class="header-anchor" href="#ob" aria-label="Permalink to &quot;\`__ob__\`&quot;">​</a></h4><p><code>__ob__</code> 为 <code>Observer</code> 实例，每一个被监听的对象（包括数组）下都会拥有一个 <code>__ob__</code> 属性，内部保存着 <code>data</code> 值和该 <code>data</code> 的订阅列表。在 <code>reactiveGetter</code> 里可以对其添加订阅：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (childOb) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  childOb.dep.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">depend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dependArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 循环给数组的每一项添加订阅</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="protoaugment" tabindex="-1">protoAugment <a class="header-anchor" href="#protoaugment" aria-label="Permalink to &quot;protoAugment&quot;">​</a></h4><p>其中，对应数组类型的监听执行 <code>protoAugment</code>，改写 <code>value</code>（数组类型）的 <code>__proto__</code> 为 <code>arrayMethods</code>，这样在执行数组方法的时候，就会被拦截执行 <code>arrayMethods</code> 对象里重写后的变异方法，在变异方法里触发通知订阅该数组订阅的列表。</p><h4 id="检测变化的注意事项-来自文档" tabindex="-1">检测变化的注意事项（来自文档） <a class="header-anchor" href="#检测变化的注意事项-来自文档" aria-label="Permalink to &quot;检测变化的注意事项（来自文档）&quot;">​</a></h4><ul><li>对于对象：<code>Vue</code> 无法检测 <code>property</code> 的添加或移除。由于 <code>Vue</code> 会在初始化实例时对属性执行 <code>getter/setter</code> 转化，所以属性必须在 <code>data</code> 对象上存在才能让 <code>Vue</code> 将它转换为响应式；</li><li>对于数组：<code>Vue</code> 无法监听通过索引（即下标）设置数组项（性能原因）和修改数组的长度（<code>length</code> 属性无法设置 <code>get/set</code>）。</li></ul><h3 id="computed" tabindex="-1">computed <a class="header-anchor" href="#computed" aria-label="Permalink to &quot;computed&quot;">​</a></h3><p>其中对 <code>computed</code> 里的每一项判断是否是 <code>SSR</code> 后，执行:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">watchers[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Watcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, getter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> noop, noop, computedWatcherOptions);</span></span></code></pre></div><p>其中 <code>watchers</code> 即 <code>vm._computedWatchers</code>，这里实例化了一个 <code>计算 watcher</code>，其中 <code>computedWatcherOptions</code> 为 <code>{lazy: true}</code>，所以不会立即得到值，进而不会触发 <code>get</code> 增加订阅。然后执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineComputed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, key, userDef);</span></span></code></pre></div><p>方法里将 <code>key</code> 挂载在实例下监听，<code>get</code> 方法为 <code>computedGetter</code>（执行 <code>createComputedGetter(key)</code>（柯里化）的结果），<code>set</code> 方法设置无法重写。</p><h3 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h3><p>其中对 <code>watch</code> 里的每一项执行:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWatcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, key, handler);</span></span></code></pre></div><p>即执行 <code>vm.$watch(expOrFn, handler, options)</code>，方法里会执行 <code>new Watcher(vm, expOrFn, cb, options)</code>，其中 <code>expOrFn:&#39;info&#39;,&#39;cb&#39;:&#39;handler&#39;,&#39;options&#39;:&#39;{handler: handler,deep: true,user: true}&#39;</code>。其中 <code>user: true</code> 表示用户自己写的 <code>watcher</code>。</p><p><code>watcher</code> 里执行 <code>this.get-&gt;this.getter</code> 方法取 <code>value</code> 时，会触发之前监听该变量的 <code>proxyGetter</code>，然后将该 <code>watcher</code> 订阅到对应变量上（<code>watcher</code> <code>push</code> 到 <code>Dep</code> 的实例属性 <code>subs</code> 里），当变量后续变化时就会通知 <code>subs</code> 里的 <code>watcher</code> 列表做更新操作。</p><p>也就是说，在执行 <code>expression</code> 获取对应 <code>value</code> 的过程中，<code>expression</code> 里涉及到哪个已经被监听的属性，都会给该属性添加本 <code>watcher</code>，即订阅。当变量后续变化就会来通知该 <code>watcher</code> 执行 <code>update</code> 操作。</p><p>此时，因为 <code>deep: true</code>，所以在 <code>Watcher.prototype.get</code> 里的 <code>finally</code> 里执行 <code>traverse(value)</code>，递归读取 <code>value</code> 对象（包含数组）的每一个属性，即会触发监听每个变量的 <code>proxyGetter</code>，将该<code>watcher</code> 订阅到所有变量上。</p><p>判断有无 <code>immediate</code> 控制是否立即执行后，返回 <code>unwatchFn</code> 提供销毁该 <code>watcher</code> 的执行方法。</p><h2 id="initprovide" tabindex="-1">initProvide <a class="header-anchor" href="#initprovide" aria-label="Permalink to &quot;initProvide&quot;">​</a></h2><p>判断是否存在 <code>$options.provide</code>，将其赋到 <code>vm._provided</code>属性上。</p><h2 id="触发-created-钩子" tabindex="-1">触发 created 钩子 <a class="header-anchor" href="#触发-created-钩子" aria-label="Permalink to &quot;触发 created 钩子&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callHook</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;created&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>执行生命周期钩子 <code>created</code>，打印 <code>vue created</code>。异步数据读取可在此钩子执行。</p><h2 id="本章小结" tabindex="-1">本章小结 <a class="header-anchor" href="#本章小结" aria-label="Permalink to &quot;本章小结&quot;">​</a></h2><ol><li>本章介绍了 <code>vue</code> 执行的 <code>created</code> 阶段；</li><li>初始化了依赖注入 <code>inject/provide</code> 相关；</li><li>对 <code>options</code> 里的 <code>props，methods，data，computed，watch</code> 属性进行处理，做一些监听，绑定，订阅之类的操作，包括数组的监听等等。</li></ol>`,50),p=[n];function h(d,l,o,k,c,r){return i(),a("div",null,p)}const y=s(t,[["render",h]]);export{g as __pageData,y as default};
