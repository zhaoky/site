# AI 对话的实现与难点解析

## 一、背景与架构

### 1.1 技术选型

本项目基于 Vue 3 + TypeScript 实现 AI 对话功能，采用 Server-Sent Events (SSE) 协议实现流式对话，核心库为 `@microsoft/fetch-event-source`。

### 1.2 整体架构

```mermaid
graph TB
    A[用户输入] --> B[useSendMessage]
    B --> C[checkSessionId<br/>会话检查]
    C --> D[addMessage<br/>添加用户消息]
    D --> E[sendInitMessage<br/>创建AI占位消息]
    E --> F[useAiRequest<br/>发起SSE请求]
    F --> G[SSESocket.post<br/>建立SSE连接]
    G --> H{SSE数据类型}
    H -->|流式文本| I[handleMessage<br/>逐字追加]
    H -->|完整消息| J[updateMessage<br/>替换消息]
    H -->|DONE| K[onComplete<br/>结束生成]
    I --> L[messageList更新]
    J --> L
    K --> L
    L --> M[UI渲染]
```

## 二、核心技术实现

### 2.1 SSE 流式通信

#### 核心配置

```typescript
// utils/im_sse.ts
export class SSESocket {
  async post(params) {
    const controller = new AbortController()

    return new Promise((resolve, reject) => {
      fetchEventSource(url, {
        method: 'POST',
        signal: controller.signal,
        openWhenHidden: true,  // 后台持续接收
        body: JSON.stringify(data),

        async onopen(response) {
          resolve(controller)
          startTimer(controller)  // 180秒超时检测
        },

        onmessage(msg) {
          const data = JSON.parse(msg.data)
          callData?.(data, messageIndex++)
        },

        onerror(err) {
          controller?.abort()
          onclose?.()
        }
      })
    })
  }
}
```

#### 关键特性

1. **后台持续连接**：`openWhenHidden: true` 确保页面切换时 SSE 不断开
2. **超时机制**：180 秒无响应自动关闭连接
3. **可中止性**：`AbortController` 支持手动中止

### 2.2 消息 ID 管理

#### 三种消息 ID

| 类型 | 生成时机 | 生成位置 | 格式 | 是否替换 |
|------|---------|---------|------|---------|
| 历史消息 | 数据库保存时 | 后端 | `{patient_seq_no}_{uuid}` | 否 |
| 用户消息 | 发送消息时 | 前端→后端 | `xxxx-timestamp-xxxxx` | 视情况 |
| AI消息 | 创建占位时 | 前端→后端 | `xxxx-timestamp-xxxxx` | 视情况 |

#### ID 生成函数

```typescript
// utils/format.ts
export function createGuid() {
  const array = new Uint32Array(2);
  crypto.getRandomValues(array);
  const randomPart1 = array[0].toString(16).substring(0, 4);
  const randomPart2 = array[1].toString(16).substring(0, 5);

  return `${randomPart1}-${Date.now()}-${randomPart2}`;
  // 示例: "a3f2-1733042320123-b4e5a"
}
```

#### ID 替换机制

```mermaid
sequenceDiagram
    participant F as 前端
    participant S as SSE服务器

    F->>F: 生成临时ID<br/>"c7d9-xxx"
    F->>F: 添加到messageList
    F->>S: POST /sse<br/>{message, sse_uuid}

    alt 流式文本模式(90%)
        loop 持续返回
            S->>F: {sseType:"TEXT", text:"你"}
            F->>F: 追加文本，ID不变
        end
        Note over F: msg_id保持"c7d9-xxx"
    else 完整消息模式(10%)
        S->>F: {messages:[{msg_id:"21182_xxx",...}]}
        F->>F: 替换ID一次
        Note over F: msg_id变为"21182_xxx"
    end

    S->>F: {text:"[DONE]"}
    F->>F: 结束生成
```

#### 替换逻辑

```typescript
// utils/im.ts
export const updateMessageState = (
  messageList: IMessage[],
  msgId: string,           // 前端ID
  updates: Partial<IMessage> // 后端消息(包含后端ID)
) => {
  const updateIndex = messageList.findIndex(item => item.msg_id === msgId)

  if (updateIndex !== -1) {
    messageList[updateIndex] = {
      ...messageList[updateIndex],  // 前端数据
      ...updates                     // 后端数据(覆盖msg_id)
    }
  }
  return { messageList, updateIndex }
}
```

**关键结论**：

- 流式文本模式：ID 始终保持前端生成的临时 ID
- 完整消息模式：ID 仅被替换一次，不会重复覆盖

### 2.3 会话管理

#### 会话切换检测

```typescript
// hooks/useSendMessage.ts
const sendMessage = async (messageData) => {
  // 每次发送前检查会话ID
  const state = await checkSessionId()

  if (state?.separator_message) {
    // 后端判断需要开始新话题
    addMessage(createMessage({
      message: '新话题',
      type: MSG_TYPE.NEW_CHAT_DIVIDER
    }))
  }

  // 继续发送消息...
}
```

#### 后端响应

```typescript
// API: /dialogue/session/get_session_id
{
  session_id: "session_id_67890",
  separator_message?: {  // 可选字段
    msg_type: "NEW_CHAT_DIVIDER",
    msg_content: "新话题"
  }
}
```

**作用**：

1. 确保使用最新的 `session_id`
2. 自动在合适时机插入"新话题"分割线
3. 支持多设备会话同步

### 2.4 双重中止机制

#### sse_uuid 的作用

```typescript
// 发送SSE请求时
const reqData = {
  message: "你好",
  sse_uuid: createGuid(),  // 唯一标识此次SSE请求
  session_id: "session_id_123",
  patient_seq_no: 21182
}

setStorage('sse_uuid', reqData.sse_uuid)
```

#### 中止流程

```typescript
// hooks/useSendMessage.ts
const stopMessage = async () => {
  const sse_uuid = getStorage('sse_uuid')

  if (sse_uuid) {
    // 1. 通知服务器停止生成
    await stopSse({ patient_seq_no, sse_uuid })
  }

  // 2. 前端中止连接
  if (currentRequestTask) {
    currentRequestTask.abort()
  }

  // 3. 清理状态
  removeStorage('sse_uuid')
  imStore.updateIsGenerating(false)
}
```

#### 为什么不用 msg_id？

| 对比项 | sse_uuid | msg_id |
|--------|----------|--------|
| 生成时机 | 请求前 | 响应后 |
| 可用性 | 立即可用 | 需等待SSE返回 |
| 作用域 | 整个SSE连接 | 单条消息 |
| 数量 | 1个 | 2个(用户+AI) |

**核心优势**：用户点击停止按钮时，`sse_uuid` 已存在，可立即中止；而 `msg_id` 可能还未返回。

## 三、性能优化策略

### 3.1 分页加载机制

```typescript
// store/modules/im.ts
state: () => ({
  messageList: [],      // 当前显示(分页)
  allMessageList: [],   // 完整缓存
  pageSize: 15,         // 每页15条
  pageIndex: 0
})
```

#### 双缓存策略

```mermaid
graph LR
    A[用户上滑] --> B{allMessageList<br/>是否为空?}
    B -->|是| C[调用API<br/>获取全部历史]
    C --> D[缓存到<br/>allMessageList]
    D --> E[切片15条]
    B -->|否| E
    E --> F[插入到<br/>messageList前面]
    F --> G[显示15/30/45条...]
```

#### 加载逻辑

```typescript
async loadMoreHistoryMessages() {
  if (this.allMessageList.length === 0) {
    // 首次：从服务器获取所有历史(如200条)
    const { messages } = await getAllMessageList({
      patient_seq_no, session_id
    })
    this.allMessageList = messages.reverse()
  }

  // 分页：从缓存中切片
  const startIndex = this.pageIndex
  const endIndex = Math.min(startIndex + 15, this.allMessageList.length)
  const newMessages = this.allMessageList.slice(startIndex, endIndex)

  // 插入到显示列表前面
  this.messageList = [...newMessages.reverse(), ...this.messageList]
  this.pageIndex = endIndex
}
```

### 3.2 按需渲染

```vue
<template>
  <!-- 只渲染 messageList 中的消息(最多15-30条) -->
  <template v-for="item in messageList" :key="`msg-${item.msg_id}`">
    <!-- 条件渲染：只加载实际需要的组件 -->
    <MessageText v-if="isTextCard(item.msg_type)" />
    <MessageImage v-if="isImageCard(item.msg_type)" />
    <!-- 其他60+种类型，未使用的不会加载 -->
  </template>
</template>
```

### 3.3 性能对比

| 方案 | 初始DOM | 内存占用 | 首屏时间 | 滚动FPS |
|------|---------|---------|---------|---------|
| 一次性加载300条 | 300+ | ~100MB | 3-5秒 | 30-40 |
| 分页加载15条 | 0-15 | ~10MB | <100ms | 55-60 |

## 四、难点与解决方案

### 4.1 滚动位置保持

**问题**：加载历史消息后，列表高度增加，导致页面跳动。

**解决**：

```typescript
const handleScroll = async () => {
  // 记录加载前的状态
  const oldScrollHeight = scrollContentRef.value.scrollHeight
  const oldScrollTop = scrollContentRef.value.scrollTop

  // 加载新消息
  await imStore.loadMoreHistoryMessages(oldScrollHeight, oldScrollTop)

  // 调整滚动位置
  nextTick(() => {
    const newScrollHeight = scrollContentRef.value.scrollHeight
    const newScrollTop = newScrollHeight - oldScrollHeight + oldScrollTop
    scrollContentRef.value.scrollTop = newScrollTop
  })
}
```

### 4.2 消息去重与合并

**问题**：SSE 可能返回用户消息和 AI 消息的完整体，需要与前端消息合并。

**解决**：

```typescript
if (data.messages) {
  const isGeneratingIndex = imStore.messageList.findIndex(
    item => item.isGenerating
  )

  // 更新用户消息(索引-1)
  updateMessage(
    data.messages[0],
    imStore.messageList[isGeneratingIndex - 1]?.msg_id
  )

  // 更新AI消息(当前索引)
  updateMessage(
    data.messages[1],
    imStore.messageList[isGeneratingIndex]?.msg_id
  )
}
```

### 4.3 状态一致性

**问题**：页面切换时，SSE 在后台继续接收，状态可能不一致。

**解决**：

```typescript
// 1. SSE配置
fetchEventSource(url, {
  openWhenHidden: true  // 后台持续接收
})

// 2. 全局状态管理
const imStore = useImStore()  // Pinia全局store
imStore.messageList  // 任何页面都能访问

// 3. 切换回聊天页
// UI自动渲染最新的messageList，无需额外处理
```

## 五、核心数据流

```mermaid
graph TB
    subgraph 前端状态
        A1[messageList<br/>显示列表]
        A2[allMessageList<br/>历史缓存]
        A3[isGenerating<br/>生成状态]
    end

    subgraph SSE处理
        B1[流式文本<br/>handleMessage]
        B2[完整消息<br/>updateMessage]
    end

    subgraph 消息来源
        C1[历史加载<br/>getAllMessageList]
        C2[用户输入<br/>addMessage]
        C3[SSE返回<br/>onmessage]
    end

    C1 --> A2
    A2 -->|分页切片| A1
    C2 --> A1
    C3 --> B1
    C3 --> B2
    B1 -->|追加文本| A1
    B2 -->|替换对象| A1
    A1 --> D[Vue响应式<br/>UI更新]
```

## 六、总结

### 关键技术点

1. **SSE 流式通信**：采用 `fetchEventSource`，支持后台持续连接和超时检测
2. **消息 ID 管理**：前端临时 ID + 后端正式 ID，分场景处理
3. **会话管理**：每次发送前检查 `session_id`，自动插入话题分割线
4. **双重中止**：`sse_uuid` 标识连接 + `AbortController` 前端中止
5. **性能优化**：分页加载 + 按需渲染 + 双缓存策略

### 设计亮点

1. **前端先行**：用户消息和 AI 占位先用前端 ID，保证即时响应
2. **后端权威**：最终以后端 ID 为准，确保数据一致性
3. **灵活处理**：支持流式更新和完整替换两种模式
4. **资源优化**：懒加载 + 分页，60+ 种消息类型也流畅

### 适用场景

- 医疗健康咨询
- 智能客服对话
- 教育辅导系统
- 任何需要流式 AI 对话的场景

## 七、后续优化方向

### 7.1 滚动监听优化

**现状问题**：使用 `scroll` 事件监听，高频触发影响性能。

**优化方案**：采用 Intersection Observer API

```typescript
// 替代方案
const useIntersectionObserver = () => {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !isLoadingMore.value) {
          // 顶部元素进入视口，加载更多
          loadMoreHistoryMessages()
        }
      })
    },
    {
      root: scrollContentRef.value,
      rootMargin: '200px 0px 0px 0px',  // 提前200px触发
      threshold: 0
    }
  )

  // 监听顶部哨兵元素
  const sentinelRef = ref<HTMLElement>()
  watch(sentinelRef, (el) => {
    if (el) observer.observe(el)
  })
}
```

**优势**：性能更好，浏览器原生优化，无需手动节流。

### 7.2 虚拟滚动

**现状问题**：历史消息较多时（500+ 条），DOM 节点过多。

**优化方案**：使用虚拟列表，只渲染可视区域

```typescript
import { useVirtualList } from '@vueuse/core'

const { list, containerProps, wrapperProps } = useVirtualList(
  messageList,
  {
    itemHeight: 100,  // 动态计算实际高度
    overscan: 5       // 预渲染5条
  }
)
```

**收益**：

- 渲染节点从 500+ 降至 20-30
- 首屏渲染时间减少 70%+
- 滚动 FPS 稳定在 60

### 7.3 消息本地缓存

**现状问题**：每次刷新页面都需重新加载历史消息。

**优化方案**：IndexedDB 持久化

```typescript
// utils/messageCache.ts
class MessageCache {
  private db: IDBDatabase

  async saveMessages(sessionId: string, messages: IMessage[]) {
    const tx = this.db.transaction('messages', 'readwrite')
    const store = tx.objectStore('messages')
    await store.put({ sessionId, messages, timestamp: Date.now() })
  }

  async getMessages(sessionId: string): Promise<IMessage[]> {
    const tx = this.db.transaction('messages', 'readonly')
    const store = tx.objectStore('messages')
    const data = await store.get(sessionId)

    // 缓存超过24小时失效
    if (data && Date.now() - data.timestamp < 86400000) {
      return data.messages
    }
    return null
  }
}
```

**收益**：离线也能查看历史消息，减少 API 请求。

### 7.4 SSE 自动重连

**现状问题**：网络波动导致 SSE 断开，用户需手动重试。

**优化方案**：断线自动重连机制

```typescript
class SSEReconnect {
  private retryCount = 0
  private maxRetries = 3

  async postWithRetry(params) {
    try {
      return await sseApi.post(params)
    } catch (error) {
      if (this.retryCount < this.maxRetries) {
        this.retryCount++
        const delay = Math.min(1000 * Math.pow(2, this.retryCount), 10000)

        await new Promise(resolve => setTimeout(resolve, delay))
        return this.postWithRetry(params)
      }
      throw error
    }
  }
}
```

**策略**：指数退避重试（1s、2s、4s），最多 3 次。

### 7.5 消息智能预加载

**现状问题**：用户滚动到顶部才加载，有明显等待。

**优化方案**：预测性加载

```typescript
const useSmartPreload = () => {
  const scrollVelocity = ref(0)
  let lastScrollTop = 0
  let lastTime = Date.now()

  const handleScroll = () => {
    const now = Date.now()
    const currentScrollTop = scrollContentRef.value.scrollTop

    // 计算滚动速度
    scrollVelocity.value =
      (lastScrollTop - currentScrollTop) / (now - lastTime)

    // 向上快速滚动，提前加载
    if (scrollVelocity.value > 2 && distanceFromTop < 500) {
      loadMoreHistoryMessages()
    }

    lastScrollTop = currentScrollTop
    lastTime = now
  }
}
```

**收益**：提前加载，用户感知延迟降低 50%+。

### 7.6 图片懒加载

**现状问题**：消息中的图片全部加载，浪费带宽。

**优化方案**：原生 lazy loading + Intersection Observer

```vue
<template>
  <img
    :src="imageSrc"
    loading="lazy"
    :data-src="highResSrc"
    @load="onImageLoad"
  />
</template>

<script setup>
const loadHighRes = (img: HTMLImageElement) => {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        img.src = img.dataset.src
        observer.unobserve(img)
      }
    })
  })
  observer.observe(img)
}
</script>
```

### 7.7 WebSocket 双向通信

**现状问题**：SSE 单向，无法主动推送服务端事件。

**适用场景**：

- 多人协作对话
- 实时状态同步
- 服务端主动推送

**方案**：WebSocket 升级

```typescript
class ChatWebSocket {
  private ws: WebSocket

  connect() {
    this.ws = new WebSocket('wss://api.example.com/chat')

    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data)

      switch (data.type) {
        case 'message':
          handleMessage(data)
          break
        case 'typing':
          showTypingIndicator(data.userId)
          break
        case 'read':
          updateReadStatus(data.msgId)
          break
      }
    }
  }

  send(message) {
    this.ws.send(JSON.stringify(message))
  }
}
```

### 7.8 离线消息队列

**现状问题**：离线时发送的消息直接丢失。

**优化方案**：消息队列 + Service Worker

```typescript
// 离线消息队列
class OfflineQueue {
  private queue: IMessage[] = []

  async addMessage(message: IMessage) {
    this.queue.push(message)
    await this.persistQueue()

    // 监听网络恢复
    window.addEventListener('online', () => this.flush())
  }

  async flush() {
    while (this.queue.length > 0) {
      const message = this.queue[0]
      try {
        await sendMessage(message)
        this.queue.shift()
      } catch {
        break  // 失败停止，等待下次重试
      }
    }
  }
}
```

### 7.9 性能监控

**优化方案**：关键指标追踪

```typescript
class ChatPerformanceMonitor {
  // SSE响应时间
  trackSSEResponse() {
    const startTime = performance.now()
    return () => {
      const duration = performance.now() - startTime
      this.report('sse_response_time', duration)
    }
  }

  // 消息渲染时间
  trackMessageRender() {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        this.report('message_render', entry.duration)
      })
    })
    observer.observe({ entryTypes: ['measure'] })
  }

  // 内存使用
  trackMemory() {
    if (performance.memory) {
      setInterval(() => {
        this.report('heap_size', performance.memory.usedJSHeapSize)
      }, 30000)
    }
  }
}
```

### 7.10 TypeScript 类型优化

**现状问题**：消息类型使用 `any`，类型不够安全。

**优化方案**：泛型 + 联合类型

```typescript
// 类型化消息
type MessageType = 'TEXT' | 'IMAGE' | 'FILE' | 'INSTRUCTION'

interface BaseMessage {
  msg_id: string
  create_time: number
  from: string
  to: string
}

interface TextMessage extends BaseMessage {
  msg_type: 'TEXT'
  msg_content: string
}

interface ImageMessage extends BaseMessage {
  msg_type: 'IMAGE'
  image_url: string
  thumbnail_url?: string
}

type Message = TextMessage | ImageMessage | FileMessage | InstructionMessage

// 类型守卫
function isTextMessage(msg: Message): msg is TextMessage {
  return msg.msg_type === 'TEXT'
}

// 使用
const handleMessage = (msg: Message) => {
  if (isTextMessage(msg)) {
    // TypeScript 知道这是 TextMessage
    console.log(msg.msg_content)  // 类型安全
  }
}
```

### 优化优先级建议

| 优先级 | 优化项 | 收益 | 复杂度 |
|--------|--------|------|--------|
| P0 | 滚动监听优化 | 高 | 低 |
| P0 | 图片懒加载 | 高 | 低 |
| P1 | SSE自动重连 | 高 | 中 |
| P1 | 消息本地缓存 | 中 | 中 |
| P2 | 虚拟滚动 | 高 | 高 |
| P2 | 智能预加载 | 中 | 中 |
| P3 | WebSocket升级 | 中 | 高 |
| P3 | 离线队列 | 中 | 高 |
| P3 | 性能监控 | 低 | 低 |
| P3 | 类型优化 | 低 | 中 |
